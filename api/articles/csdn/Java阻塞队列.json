{"title":"Java阻塞队列","uid":"32c93abe435d8f794f6c98ee11259476","slug":"csdn/Java阻塞队列","date":"2022-10-10T09:52:53.000Z","updated":"2025-02-17T04:22:34.793Z","comments":true,"path":"api/articles/csdn/Java阻塞队列.json","keywords":"Stephen web3","cover":[],"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>        队列是种只允许在表的前端进行删除操作，而在表的后端进行插入操作的线性表。阻塞队列和一般队列的不同之处在于阻塞队列是“阻塞”的，这里的阻塞指的是操作队 列的线程的一种状态。在阻塞队列中，线程阻塞有如下两种情况：</p>\n<ul>\n<li>消费者阻塞：在队列为空时·，消费者端的线程都会被自动阻塞（挂起），直到有数据放入队列，消费者线程会被自动唤醒并消费数据，如图所示</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/e20b9a12434da54dcef19e0c39b55731.png\"></p>\n<ul>\n<li>生产者阻塞：在队列已满且没有可用空间时，生产者端的线程都会被自动阻塞（挂起），直到队列中有空的位置腾出，线程会被自动唤醒并生产数据，如图所示</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/68684cff7d6d1e1f10a2b5967b0e8b26.png\"></p>\n<h2 id=\"一、阻塞队列的主要操作\"><a href=\"#一、阻塞队列的主要操作\" class=\"headerlink\" title=\"一、阻塞队列的主要操作\"></a>一、阻塞队列的主要操作</h2><p>阻塞队列的主要操作有插入操作和移除操作。插入操作有 a dd(e) 、o ffer(e)、 put(e)、offer(e,time,unit), 移除操作有 remove()、 poll ( )、take() 、poll(time,unit) ，具体介绍如下</p>\n<h3 id=\"1-插入操作\"><a href=\"#1-插入操作\" class=\"headerlink\" title=\"1.插入操作\"></a>1.插入操作</h3><ul>\n<li>public abstract boolean add(E paramE): 将指定的元素插人队列中，在成功时返回 ture,如果当前没有可用的空间，则抛出IllegalStateException。如果该元素是null， 则抛出NullPointerException异常。Jdk源码的实现如下：</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/d112146d09795395128542d9ef4e356c.png\">  \n </p>\n<ul>\n<li>public abstract boolean offer(E paramE): 将指定的元素插入队列中，在成功时返回true,如果当前没有可用的空间，则返回false。jdk源码的实现如下：</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/8df88149d3510d46037647763977aa98.png\"></p>\n<ul>\n<li><p>offer(E o, long timeout, TimeUnit unit）： 将指定的元素插入队列中，可以设定等待的时间，如果在设定的等待时间内仍不能向队列中加入元素， 则返回 false。</p>\n</li>\n<li><p>public abstract void put(E p aramE) throws InterruptedException 将指定的元素插入队列中，如果队列已经满了， 则阻塞、等待可用的队列空间的释放，直到有可用的队列空间释放且插入成功为止，JDK 源码的实现如下</p>\n</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/a4c8c3bb2780429547b983d96e961b63.png\"></p>\n<h3 id=\"2-获取数据操作\"><a href=\"#2-获取数据操作\" class=\"headerlink\" title=\"2.获取数据操作\"></a>2.获取数据操作</h3><ul>\n<li>poll(）取走队列队首的对象，如果取不到数据，则返回null。jdk源码的实现如下：</li>\n</ul>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/9b4d35f6904db7dc07f455b13f34194f.png\"></p>\n<ul>\n<li><p>poll(long timeout, T imeUnit unit )：取走列队首的对象，如果在指定的时间内队列有数据可取，则返回队列中的数据，否则等待一定时间 ，在等待超时并且没有数据可取时，返回null。</p>\n</li>\n<li><p>take ()取走列队首的对象,如果队列为空，则进入阻塞状态等待，知道队列有新的数据被加入，再及时取出新加入的数据。jdk源码的实现如下<img src=\"https://i-blog.csdnimg.cn/blog_migrate/7761c3c35a66c76622a4832435a9f013.png\"></p>\n</li>\n<li><p>drainTo(Collection collection） 一次性从队列中批量获取所有可用的数据对象，同时可以指定获取数据的个数，通过该方法可以提升获取数据的效率， 避免多次频繁操 作引起的队列锁定。</p>\n</li>\n</ul>\n<p> </p>\n<h2 id=\"二、Java中的阻塞队列实现\"><a href=\"#二、Java中的阻塞队列实现\" class=\"headerlink\" title=\"二、Java中的阻塞队列实现\"></a>二、Java中的阻塞队列实现</h2><p>Java 中 的阻塞 队列有： ArrayBlockingQueue 、LinkedBlockingQueue 、PriorityBlockingQueue 、DelayQueue、SynchronousQueue、LinkedTransferQueue、LinkedBlockingDeque。具体功能如下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/8d93c56ca9acd5ebd1c2601a00761386.png\"></p>\n<ul>\n<li>ArrayBlockingQueue</li>\n</ul>\n<p>        ArrayBlockingQueue 是基于数组实 现的有界阻塞 队列。ArrayBlockingQueue 队列按照 先进先出原则对元素进行排序，在 默认情 况下不保证元 素操 作的 公平性。</p>\n<p>        队列操作的公平性指在生 产者线程或消费者线程发生 阻塞 后再次被 唤醒时，按照 阻塞的先 后顺序操作队列， 即先阻塞 生产者线程 优先向队列中插入元素，先阻塞的消费 者线程 优先从队列中 获取元素 。 因为保证公平性会降低吞吐 ，所 以如果要 处理的 数据 没有先后顺序， 则对 其可 以使用非 公平处理 的方式。我 们可以通 过以下代码创建一 个公平或者非公平的阻塞 队列：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/8352a751a5f7beeb5d94bc42024930ef.png\"></p>\n<ul>\n<li> LinkedBlockingQueue</li>\n</ul>\n<p>LinkedBlockingQueue是基于链表实现的阻塞队列，同ArrayBlockingQueue类似，此队列按照先进先出原则对元素进行排序，LinkedBlockingQueue对生产者端和消费者端分别采用两个独立的锁来控制数据同步，我们可以将队列头部的锁理解为写锁，尾部的锁理解成读锁，因此生产者和消费者可以基于各自独立的锁并行的操作队列中的数据，队列的并发性能较高，具体用法如下：<img src=\"https://i-blog.csdnimg.cn/blog_migrate/1007cfcb2e8c9dc6f5e88ad0cdb6b5b6.png\"></p>\n<ul>\n<li>PriorityBlockingQueue</li>\n</ul>\n<p>PriorityBlockingQueue是一个支持优先级的无界队列。元素在默认情况下采用自然顺序升序排序。可以自定义实现compareTo方法来指定元素进行排序规则，或者在初始化PriorityBlockingQueue时指定构造参数Comparator来实现对元素的排序。注意：如果两个元素的优先级相同，则不能保证该元素的存储和访问顺序。具体用法如下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/23c5b7661f6b0d14c2e183be93b996a4.png\"></p>\n<ul>\n<li> DelayQueue</li>\n</ul>\n<p>        DelayQueue是一个支持延时获取元素的无界阻塞队列，在队列底层使用PriorityQueue实现。DelayQueue队列中的元素必须实现Delayed接口，该接口定义了在创建元素时该元素的延迟时间，在内部通过为每个元素的操作加锁来保障数据的一致性。只有在延迟时间到后才能从队列中提取元素。我们可以将 DelayQueue运用于以下场景中</p>\n<p>         缓存系统的设计：可以用 DelayQueue保存缓存元素的有效期，使用一个线程循环查询DelayQueue一旦能从 DelayQueue 获取元素， 表示缓存的有效期到了。</p>\n<p>        定时任务调度：使用 DelayQueue 保存即将执行的任务和执行时间，一旦从 DelayQueue 中获取元素，就表示任务开始执行，Java 中的 TimerQueue 就是使用 DelayQueue 实现的。</p>\n<p>        在具体使用时，延迟对象必须先实现Delayed类并实现其getDelay方法和compareTo方法，才可以在延迟队列中使用：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/4b922c5d8924ac9128a0b0a7cd510aa4.png\"></p>\n<ul>\n<li> SynchronousQueue</li>\n</ul>\n<p>SynchronousQueue时一个不存储元素的阻塞队列。SynchronousQueue中的每一个put操作都必须等待一个take操作完成，否则不能继续添加元素。我们可以将SynchronousQueue看作一个快递员，它负责把生产者线程的数据直接传递给消费线程，非常适用于传递型场景，比如将在一个线程中使用的数据传递给另一个线程使用。SynchronousQueue的吞吐量高于ArrayBlockingQueue 、LinkedBlockingQueue，具体的使用方法如下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/f28b02722afca4c521c072afaaf60886.png\"><img src=\"https://i-blog.csdnimg.cn/blog_migrate/9a4a24ad720da02532f073a439525d0f.png\"> </p>\n<ul>\n<li> LinkedTransferQueue</li>\n</ul>\n<p>        LinkedTransferQueue是基于链表结构实现的无界阻塞TransferQueue队列。相对于其他阻塞队列，LinkedTransferQueue多了个transfer、tryTransfer和tryTransfer(E e,long timeout,TimeUint unit)方法。</p>\n<p>        transfer方法：如果当前有消费者正在等待接收元素， transfer 方法就会直接把生产者传入的元素投递给消费者并返回 true。如果没有消费者在等待接收元素，transfer 方法就会将元素存放在队列的尾部（ taiI ）节点，直到该元素被消费后才返回。</p>\n<p>tryTransfer方法:首先尝试能否将生产者传入的元素直接传给消费者，如果没有消费者等待接收元素，则返回 false。和transfer方法的区别是，无论消费者是否接收元素，tryTransfer方法都立即返回，而 transfer 方法必须等到元素被消费后才返回。</p>\n<p>tryTransfer(E e,long timeout,TimeUint unit)方法：首先尝试生产者传入的元素直接传给消费者，如果没有消费者，则等待指定的时间，在超时后如果元素还没 有被消费，则返回 false ，否则返回true。</p>\n<ul>\n<li>LinkedBlockingDeque</li>\n</ul>\n<p>        LinkedBlockingDeque是基于链表结构实现的双向阻塞队列，可以在队列的两端分别执行插入和移出元素操作。这样，在多线程同时操作队列时，可以减少一半的锁资源竞争，提高队列的操作效率。</p>\n<p>        LinkedBlockingDeque 相比其他阻塞 队列， 多了 addFirst、 addLast、 offer First、offerLast、 peekFirst 、 peekLast 等方法 First 结尾的方法 表示在 队列头部执行插入 (add ）、获取（ peek ）、移除（ offer ）操 作；以 Last 结尾的方法 表示在 队列的尾部执行插 入、获取、移除操作。</p>\n<p>        在初始化LinkedBlockingDeque 时，可以设置队列的大小以防止内存溢出，双向阻塞 队列也常被用于工作窃取模。</p>\n<p>Article link： <a href=\"https://tqgoblin.site/post/csdn/Java%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/\">https://tqgoblin.site/post/csdn/Java阻塞队列/</a> <div align=left> Author：<a href=\"https://www.tqgoblin.site\"> Stephen </a> </div></p>\n","text":"概述 队列是种只允许在表的前端进行删除操作，而在表的后端进行插入操作的线性表。阻塞队列和一般队列的不同之处在于阻塞队列是“阻塞”的，这里的阻塞指的是操作队 列的...","permalink":"/post/csdn/Java阻塞队列","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">概述</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">一、阻塞队列的主要操作</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">1.插入操作</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">2.获取数据操作</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81Java%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">二、Java中的阻塞队列实现</span></a></li></ol>","author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"什么是 CAS","uid":"2a388c0d390bb47b986af930ed26f977","slug":"csdn/什么是 CAS","date":"2022-10-10T14:58:41.000Z","updated":"2025-02-17T04:22:34.834Z","comments":true,"path":"api/articles/csdn/什么是 CAS.json","keywords":"Stephen web3","cover":[],"text":"一、CAS 的概念：比较并交换 CAS (Compare And Swap）指比较并交换。CAS算法 CAS(V,E,N)包含3个参数，V表示要更新的变量，E表...","permalink":"/post/csdn/什么是 CAS","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"Java java 面试","slug":"Java-java-面试","count":1,"path":"api/tags/Java-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"如何排查java程序导致的cpu和内存过高异常","uid":"f003f641d410fd391760b84b742d0677","slug":"csdn/如何排查java程序导致的cpu和内存过高异常","date":"2022-10-09T06:32:40.000Z","updated":"2025-02-17T04:22:34.809Z","comments":true,"path":"api/articles/csdn/如何排查java程序导致的cpu和内存过高异常.json","keywords":"Stephen web3","cover":[],"text":"引言Java程序在实际生产过程中经常遇到CPU或内存使用率高的问题，那么应该如何排查问题的原因呢，本文大概描述一下排查方法。 一、命令方式分析1.排查占用CPU...","permalink":"/post/csdn/如何排查java程序导致的cpu和内存过高异常","photos":[],"count_time":{"symbolsCount":828,"symbolsTime":"1 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"Java linux jvm","slug":"Java-linux-jvm","count":1,"path":"api/tags/Java-linux-jvm.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}