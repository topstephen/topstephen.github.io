{"title":"HashMap底层原理","uid":"5c0f27a0ed8d73f08892501931e4fc3a","slug":"csdn/HashMap底层原理","date":"2022-10-18T08:56:52.000Z","updated":"2025-02-17T04:33:24.500Z","comments":true,"path":"api/articles/csdn/HashMap底层原理.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/blog/bimg/68db4265-fa19-408a-81bc-d8ebed6537db.jpg","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><span id=\"more\"></span>\n\n<h2 id=\"一、HashMap\"><a href=\"#一、HashMap\" class=\"headerlink\" title=\"一、HashMap\"></a>一、HashMap</h2><p><strong>特点：数组＋链表存储数据 线理不安全</strong></p>\n<p>默认数组大小16，2倍扩容，扩容因子0.75</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/6974830799be6d32061c33642930a72c.png\"></p>\n<p>        HashMap 基于键 HashCode 值唯一标识一条数据，根据hashCode定位到数组的具体下标，然后对存储的链表进行遍历查找到需要的数据，复杂度O(n).其中链表中每个元素都是一个Entry实例，包换4个属性，key,value,hash,next指向。</p>\n<p>        为了减小链表遍历的开销，java8改成数组+链表+红黑树的方式，当链表元素超过8后会将链表结构转化成红黑树，提高查询效率。时间复杂度为O(logN),长度小于8的话会重新转化成链表。</p>\n<p>        HashMap 非线程安全的， 即在同一时刻有多个线程同时写 HashMap 时将可能导致数据的不一致，1.7版本也有可能导致链表成环问题，查询map导致死循环cpu飙升。1.8解决了这个问题。如果需要满足线程安全的条件， 则可以用 Collections synchronizedMap方法使 HashMap 具有线程安全的能力，或者使用 ConcurrentHashMap</p>\n<h2 id=\"二、hashMap链表成环现象（死循环）\"><a href=\"#二、hashMap链表成环现象（死循环）\" class=\"headerlink\" title=\"二、hashMap链表成环现象（死循环）\"></a>二、hashMap链表成环现象（死循环）</h2><p><strong>1.7hashMap链表成环的时机</strong></p>\n<ol>\n<li>HashMap 扩容时。</li>\n<li>多线程环境下。</li>\n</ol>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/cca78f3b2194c78073ac7775f6684dfe.png\"></p>\n<ol>\n<li>插入的时候和平时我们追加到尾部的思路是不一致的，是链表的头结点开始循环插入，导致插入的顺序和原来链表的顺序相反的。</li>\n<li>table 是共享的，table 里面的元素也是共享的，扩容的transfer方法中while 循环都直接修改 table 里面的元素的 next 指向，导致指向混乱。</li>\n</ol>\n<p><strong>1.8版本解决方案</strong></p>\n<p>        JDK 8 中扩容时，已经没有 JDK7 中的 transfer 方法了，而是自己重新写了扩容方法，叫做 resize，链表从老数组拷贝到新数组时的代码如下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/b4bdb97e09e75f3a624da310256d73e9.png\"></p>\n<p>解决办法其实代码中的注释已经说的很清楚了，我们总结一下：</p>\n<p>        JDK8 是等链表整个 while 循环结束后，才给数组赋值，此时使用局部变量 loHead 和 hiHead来保存链表的值，因为是局部变量，所以多线程的情况下，肯定是没有问题的。</p>\n<p>        为什么有 loHead 和 hiHead两个新老值来保存链表呢，主要是因为扩容后，链表中的元素的索引位置是可能发生变化的</p>\n<p>        jdk8采用的插入方式是尾插法，jdk7是头插法。</p>\n<h2 id=\"三、ConcurrentHashMap\"><a href=\"#三、ConcurrentHashMap\" class=\"headerlink\" title=\"三、ConcurrentHashMap\"></a>三、ConcurrentHashMap</h2><p>        众所周知，在 Java 中，HashMap 是非线程安全的，如果想在多线程下安全的操作 map，主要有以下解决方法：</p>\n<ul>\n<li>第一种方法，使用Hashtable线程安全类；</li>\n<li>第二种方法，使用Collections.synchronizedMap方法，对方法进行加同步锁；</li>\n<li>第三种方法，使用并发包中的ConcurrentHashMap类；</li>\n</ul>\n<p>        第一种方法Hashtable 是一个线程安全的类，Hashtable 几乎所有的添加、删除、查询方法都加了synchronized同步锁！</p>\n<p>        第二种方法，使用Collections.synchronizedMap方法本质也是对 HashMap进行全表锁，多线程环境下性能依然也非常差</p>\n<p>        第三种方法，ConcurrentHashMap 类所采用的正是分段锁的思想，将 HashMap 进行切割，把 HashMap 中的哈希数组切分成小数组，每个小数组有 n 个 HashEntry 组成，其中小数组继承自ReentrantLock（可重入锁），这个小数组名叫Segment</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/ed108210edf99e5c3a1ea191338959fa.png\"></p>\n<p>        JDK1.7 和 JDK1.8 对 ConcurrentHashMap 的实现有很大的不同</p>\n<p>        JDK1.8 对 HashMap 做了改造，当冲突链表长度大于 8 时，会将链表转变成红黑树结构</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/d4d1ab5a985060dd285a33cd525f350c.png\"></p>\n<p>        JDK1.8 中 ConcurrentHashMap 类取消了 Segment 分段锁，采用 CAS + synchronized 来保证并发安全，数据结构跟 jdk1.8 中 HashMap 结构类似，都是数组 + 链表（当链表长度大于 8 时，链表结构转为红黑二叉树）结构。</p>\n<p>        ConcurrentHashMap 中 synchronized 只锁定当前链表或红黑二叉树的首节点，只要节点 hash 不冲突，就不会产生并发，相比 JDK1.7 的 ConcurrentHashMap 效率又提升了 N 倍！</p>\n<p>        HashEntry和HashMap中的Entry非常类似，唯一的区别就是其中的核心数据如value 以及next都使用了volatile关键字修饰，保证了多线程环境下数据获取时的可见性！</p>\n<p>Article link： <a href=\"https://tqgoblin.site/post/csdn/HashMap%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/\">https://tqgoblin.site/post/csdn/HashMap底层原理/</a> <div align=left> Author：<a href=\"https://www.tqgoblin.site\"> Stephen </a> </div></p>\n","text":" 一、HashMap特点：数组＋链表存储数据 线理不安全 默认数组大小16，2倍扩容，扩容因子0.75 HashMap 基于键 HashCode 值唯一标识一条...","permalink":"/post/csdn/HashMap底层原理","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"面试 java","slug":"面试-java","count":1,"path":"api/tags/面试-java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81HashMap\"><span class=\"toc-text\">一、HashMap</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81hashMap%E9%93%BE%E8%A1%A8%E6%88%90%E7%8E%AF%E7%8E%B0%E8%B1%A1%EF%BC%88%E6%AD%BB%E5%BE%AA%E7%8E%AF%EF%BC%89\"><span class=\"toc-text\">二、hashMap链表成环现象（死循环）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81ConcurrentHashMap\"><span class=\"toc-text\">三、ConcurrentHashMap</span></a></li></ol>","author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"kafka的rebalance机制","uid":"4a7935236206ce0c80a1379bd98b2262","slug":"csdn/kafka的rebalance机制","date":"2022-11-10T08:01:25.000Z","updated":"2025-02-17T04:35:04.466Z","comments":true,"path":"api/articles/csdn/kafka的rebalance机制.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/blog/bimg/toolbagShader.png","text":"一、Reblance是什么 Reblance就像他的名称一样，意思是再平衡，平衡什么？平衡消费者和分区之间的对应关系。本质上来讲，Reblance是一种协议，规...","permalink":"/post/csdn/kafka的rebalance机制","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"kafka kafka 面试","slug":"kafka-kafka-面试","count":1,"path":"api/tags/kafka-kafka-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Spring加载流程","uid":"92e817b0edbefb52af49230332579af2","slug":"csdn/Spring加载流程","date":"2022-10-18T08:43:29.000Z","updated":"2025-02-17T04:22:34.847Z","comments":true,"path":"api/articles/csdn/Spring加载流程.json","keywords":"Stephen web3","cover":[],"text":"一、spring加载流程 tomcat在启动ServletContext容器的时候会发布ServletContextEvent事件，Spring就通过实现Ser...","permalink":"/post/csdn/Spring加载流程","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"spring spring java 面试","slug":"spring-spring-java-面试","count":1,"path":"api/tags/spring-spring-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}