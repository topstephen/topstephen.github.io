{"title":"什么是 CAS","uid":"2a388c0d390bb47b986af930ed26f977","slug":"csdn/什么是 CAS","date":"2022-10-10T14:58:41.000Z","updated":"2025-02-17T01:58:21.607Z","comments":true,"path":"api/articles/csdn/什么是 CAS.json","keywords":"Stephen web3","cover":[],"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><span id=\"more\"></span>\n\n<h2 id=\"一、CAS-的概念：比较并交换\"><a href=\"#一、CAS-的概念：比较并交换\" class=\"headerlink\" title=\"一、CAS 的概念：比较并交换\"></a>一、CAS 的概念：比较并交换</h2><p>        CAS (Compare And Swap）指比较并交换。CAS算法 CAS(V,E,N)包含3个参数，V表示要更新的变量，E表示预期的值，N表示新值。 在且仅在V值等于E值时，才会将V值设为N，如果V值和E值不同，则说明已经有其他线程做了更新，当前线程什么都不做。 最后CAS返回当前V的真实值。</p>\n<h2 id=\"二、CAS-的特性：乐观锁\"><a href=\"#二、CAS-的特性：乐观锁\" class=\"headerlink\" title=\"二、CAS 的特性：乐观锁\"></a>二、CAS 的特性：乐观锁</h2><p>        CAS操作采用了乐观锁的思想，总是认为自己可以成功完成操。在有多个线程同时使用CAS操作一个变量时，只有一个会胜出并成功更新，其余均会失败。失败的线程不会被挂起，仅被告知失败，并且允许再次尝试，当然，也允许失败的线程放弃操作。基于这样的原理，CAS 操作即使没有锁，也可以发现其他线程对当前线程的干扰，并进行恰当的处理。</p>\n<h2 id=\"三、CAS-自旋等待\"><a href=\"#三、CAS-自旋等待\" class=\"headerlink\" title=\"三、CAS 自旋等待\"></a>三、CAS 自旋等待</h2><p>        在JDK的原子包java.util.concurrent.atomic 里面提供了一组原子类，这些原子类的基本特性就是在多线程环境下，在有多个线程同时执行这些类的实例包含的方法时，会有排他性。其内部便是基于CAS算法实现的,即在某个线程进入方法中执行其中的指令时，不会被其它线程打断；而别的线程就像自旋锁一样，一直等待该方法执行完成才由JVM从等待的队列中选择另一个线程进入。<br>        相对于synchronized阻塞算法，CAS是非阻塞算法的一种常见实现。由于CPU的切换比CPU指令集的操作更加耗时，所以 CAS 的自旋操作在性能上有了很大的提升。JDK具体的实现源码如下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/24d06eaf246337ad32203429d01ecffc.png\"><br>        在以上代码中， getAndlncrement采用了 CAS操作，每次都从内存中读取数数据然后将此数据和加1的结果进行CAS操作，如果成功，则返回结果，否则重试值到成功为止。 </p>\n<h2 id=\"四、ABA-问题\"><a href=\"#四、ABA-问题\" class=\"headerlink\" title=\"四、ABA 问题\"></a>四、ABA 问题</h2><p>        对CAS算法的实现有个重要的前提：需要取出内存中某个时刻的数据，然后在下一时刻进行比较、替换，在这个时间差内可能数据已经发生了变化，导致产生ABA问题。<br>        ABA问题指第1个线程从内存的V位置取出A，这时第2个线程也从内存中取A,并将V位置的数据首先修改为B，接着又将V位置的数据修改为A，这时第1个线程在进行CAS操作时会发现在内存中仍然是A，然后第1个线程操作成功。尽管从第1个线程的角度来说CAS操作是成功的，但在该过程中其实V位置的数据发生了变化，只是第1线程没有感知到罢了，这在某些应用场景下可能出现过程数据不一致的问题。<br>        部分乐观锁是通过版本号（version）来解决 ABA 问题的，具体的操作是乐观锁每次在执行数据的修改操作时都会带上一个版本号，在预期的版本号和数据的版本号一致时就可以执行修改操作，并对版本号执行加1操作，否则执行失败。因为每次操作的版本号都会随之增加，所以不会出现 ABA 问题，因为版本号只会增加，不会减少。</p>\n<p>Article link： [<a href=\"https://tqgoblin.site/post/csdn/%E4%BB%80%E4%B9%88%E6%98%AF\">https://tqgoblin.site/post/csdn/什么是</a> CAS&#x2F;](<a href=\"https://tqgoblin.site/post/csdn/%E4%BB%80%E4%B9%88%E6%98%AF\">https://tqgoblin.site/post/csdn/什么是</a> CAS&#x2F;) <div align=left> Author：<a href=\"https://www.tqgoblin.site\"> Stephen </a> </div></p>\n","text":" 一、CAS 的概念：比较并交换 CAS (Compare And Swap）指比较并交换。CAS算法 CAS(V,E,N)包含3个参数，V表示要更新的变量，E...","permalink":"/post/csdn/什么是 CAS","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"java java 面试","slug":"java-java-面试","count":1,"path":"api/tags/java-java-面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81CAS-%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%AF%94%E8%BE%83%E5%B9%B6%E4%BA%A4%E6%8D%A2\"><span class=\"toc-text\">一、CAS 的概念：比较并交换</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81CAS-%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81\"><span class=\"toc-text\">二、CAS 的特性：乐观锁</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81CAS-%E8%87%AA%E6%97%8B%E7%AD%89%E5%BE%85\"><span class=\"toc-text\">三、CAS 自旋等待</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81ABA-%E9%97%AE%E9%A2%98\"><span class=\"toc-text\">四、ABA 问题</span></a></li></ol>","author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"什么是AQS","uid":"7d9db4929e21c0d91333dbdc28b79909","slug":"csdn/什么是AQS","date":"2022-10-10T15:35:06.000Z","updated":"2025-02-17T01:58:21.600Z","comments":true,"path":"api/articles/csdn/什么是AQS.json","keywords":"Stephen web3","cover":[],"text":" AQS ( Abstract Queued Synchronizer ）是一个抽象的队列同步器，通过维护一个共享资源状态（ Volatile Int Stat...","permalink":"/post/csdn/什么是AQS","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"java","slug":"java","count":6,"path":"api/categories/java.json"}],"tags":[{"name":"面试 java 面试","slug":"面试-java-面试","count":1,"path":"api/tags/面试-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Java阻塞队列","uid":"32c93abe435d8f794f6c98ee11259476","slug":"csdn/Java阻塞队列","date":"2022-10-10T09:52:53.000Z","updated":"2025-02-17T01:58:21.600Z","comments":true,"path":"api/articles/csdn/Java阻塞队列.json","keywords":"Stephen web3","cover":[],"text":" 概述 队列是种只允许在表的前端进行删除操作，而在表的后端进行插入操作的线性表。阻塞队列和一般队列的不同之处在于阻塞队列是“阻塞”的，这里的阻塞指的是操作队 列...","permalink":"/post/csdn/Java阻塞队列","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"java","slug":"java","count":6,"path":"api/categories/java.json"}],"tags":[{"name":"java","slug":"java","count":2,"path":"api/tags/java.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}