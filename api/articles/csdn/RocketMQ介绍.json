{"title":"RocketMQ介绍","uid":"23a83ea7b13859971f6150dc36d3dd3b","slug":"csdn/RocketMQ介绍","date":"2022-11-10T09:36:17.000Z","updated":"2025-02-17T04:31:59.814Z","comments":true,"path":"api/articles/csdn/RocketMQ介绍.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/UTOOLS1577681541276.jpg","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"RocketMQ-整体架构设计\"><a href=\"#RocketMQ-整体架构设计\" class=\"headerlink\" title=\"RocketMQ 整体架构设计\"></a>RocketMQ 整体架构设计</h2><p>        整体的架构设计主要分为四大部分，分别是：Producer、Consumer、Broker、NameServer。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/b3a2d34ab961eab082400d817b1b8139.png\"></p>\n<p>为了更贴合实际，我画的都是集群部署，像 Broker 我还画了主从。</p>\n<p>        Producer：就是消息生产者，可以集群部署。它会先和 NameServer 集群中的随机一台建立长连接，得知当前要发送的 Topic 存在哪台 Broker Master上，然后再与其建立长连接，支持多种负载平衡模式发送消息。Consumer：消息消费者，也可以集群部署。它也会先和 NameServer 集群中的随机一台建立长连接，得知当前要消息的 Topic 存在哪台 Broker Master、Slave上，然后它们建立长连接，支持集群消费和广播消费消息。Broker：主要负责消息的存储、查询消费，支持主从部署，一个 Master 可以对应多个 Slave，Master 支持读写，Slave 只支持读。Broker 会向集群中的每一台 NameServer 注册自己的路由信息。NameServer：是一个很简单的 Topic 路由注册中心，支持 Broker 的动态注册和发现，保存 Topic 和 Borker 之间的关系。通常也是集群部署，但是各 NameServer 之间不会互相通信， 各 NameServer 都有完整的路由信息，即无状态。我再用一段话来概括它们之间的交互：</p>\n<p>        先启动 NameServer 集群，各 NameServer 之间无任何数据交互，Broker 启动之后会向所有 NameServer 定期（每 30s）发送心跳包，包括：IP、Port、TopicInfo，NameServer 会定期扫描 Broker 存活列表，如果超过 120s 没有心跳则移除此 Broker 相关信息，代表下线。</p>\n<p>        这样每个 NameServer 就知道集群所有 Broker 的相关信息，此时 Producer 上线从 NameServer 就可以得知它要发送的某 Topic 消息在哪个 Broker 上，和对应的 Broker （Master 角色的）建立长连接，发送消息。</p>\n<p>        Consumer 上线也可以从 NameServer 得知它所要接收的 Topic 是哪个 Broker ，和对应的 Master、Slave 建立连接，接收消息。</p>\n<p>        简单的工作流程如上所述，相信大家对整体数据流转已经有点印象了，我们再来看看每个部分的详细情况。</p>\n<h2 id=\"NameServer\"><a href=\"#NameServer\" class=\"headerlink\" title=\"NameServer\"></a>NameServer</h2><p>        它的特点就是轻量级，无状态。角色类似于 Zookeeper 的情况，从上面描述知道其主要的两个功能就是：Broker 管理、路由信息管理。</p>\n<p>总体而言比较简单，我再贴一些字段，让大家有更直观的印象知道它存储了些什么。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/bf38f70af875f38813eb4d41221802ec.png\"></p>\n<h2 id=\"Producer\"><a href=\"#Producer\" class=\"headerlink\" title=\"Producer\"></a>Producer</h2><p>        Producer 无非就是消息生产者，那首先它得知道消息要发往哪个 Broker ，于是每 30s 会从某台 NameServer 获取 Topic 和 Broker 的映射关系存在本地内存中，如果发现新的 Broker 就会和其建立长连接，每 30s 会发送心跳至 Broker 维护连接。并且会轮询当前可以发送的 Broker 来发送消息，达到负载均衡的目的，在同步发送情况下如果发送失败会默认重投两次（retryTimesWhenSendFailed &#x3D; 2），并且不会选择上次失败的 broker，会向其他 broker 投递。在异步发送失败的情况下也会重试，默认也是两次 （retryTimesWhenSendAsyncFailed &#x3D; 2），但是仅在同一个 Broker 上重试。</p>\n<h3 id=\"Producer-启动流程\"><a href=\"#Producer-启动流程\" class=\"headerlink\" title=\"Producer 启动流程\"></a>Producer 启动流程</h3><p>然后我们再来看看 Producer 的启动流程看看都干了些啥。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/729b0520859ca85c922ef1b2b6bcb8ab.png\"></p>\n<p>        大致启动流程图中已经表明的很清晰的，但是有些细节可能还不清楚，比如重平衡啊，TBW102 啥玩意啊，有哪些定时任务啊，别急都会提到的。</p>\n<p>有人可能会问这生产者为什么要启拉取服务、重平衡？</p>\n<p>        因为 Producer 和 Consumer 都需要用 MQClientInstance，而同一个 clientId 是共用一个 MQClientInstance 的， clientId 是通过本机 IP 和 instanceName（默认值 default）拼起来的，所以多个 Producer 、Consumer 实际用的是一个MQClientInstance。</p>\n<p>至于有哪些定时任务，请看下图：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/d096fdcf386745080510c87fd7efe2c3.png\"></p>\n<h3 id=\"Producer-发消息流程\"><a href=\"#Producer-发消息流程\" class=\"headerlink\" title=\"Producer 发消息流程\"></a>Producer 发消息流程</h3><p>        我们再来看看发消息的流程，大致也不是很复杂，无非就是找到要发送消息的 Topic 在哪个 Broker 上，然后发送消息。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/4d37bde5390de29ad047cf89bd6cb31b.png\"></p>\n<p>        现在就知道 TBW102 是啥用的，就是接受自动创建主题的 Broker 启动会把这个默认主题登记到 NameServer，这样当 Producer 发送新 Topic 的消息时候就得知哪个 Broker 可以自动创建主题，然后发往那个 Broker。</p>\n<p>        而 Broker 接受到这个消息的时候发现没找到对应的主题，但是它接受创建新主题，这样就会创建对应的 Topic 路由信息。</p>\n<h2 id=\"自动创建主题的弊端\"><a href=\"#自动创建主题的弊端\" class=\"headerlink\" title=\"自动创建主题的弊端\"></a>自动创建主题的弊端</h2><p>        自动创建主题那么有可能该主题的消息都只会发往一台 Broker，起不到负载均衡的作用。</p>\n<p>        因为创建新 Topic 的请求到达 Broker 之后，Broker 创建对应的路由信息，但是心跳是每 30s 发送一次，所以说 NameServer 最长需要 30s 才能得知这个新 Topic 的路由信息。</p>\n<p>        假设此时发送方还在连续快速的发送消息，那 NameServer 上其实还没有关于这个 Topic 的路由信息，所以有机会让别的允许自动创建的 Broker 也创建对应的 Topic 路由信息，这样集群里的 Broker 就能接受这个 Topic 的信息，达到负载均衡的目的，但也有个别 Broker 可能，没收到。</p>\n<p>        如果发送方这一次发了之后 30s 内一个都不发，之前的那个 Broker 随着心跳把这个路由信息更新到 NameServer 了，那么之后发送该 Topic 消息的 Producer 从 NameServer 只能得知该 Topic 消息只能发往之前的那台 Broker ，这就不均衡了，如果这个新主题消息很多，那台 Broker 负载就很高了。</p>\n<p>所以不建议线上开启允许自动创建主题，即 autoCreateTopicEnable 参数。</p>\n<h2 id=\"发送消息故障延迟机制\"><a href=\"#发送消息故障延迟机制\" class=\"headerlink\" title=\"发送消息故障延迟机制\"></a>发送消息故障延迟机制</h2><p>        有一个参数是 sendLatencyFaultEnable，默认不开启。这个参数的作用是对于之前发送超时的 Broker 进行一段时间的退避。</p>\n<p>        发送消息会记录此时发送消息的时间，如果超过一定时间，那么此 Broker 就在一段时间内不允许发送。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/e5aa7838b22a134c4909dfc87012e574.png\"></p>\n<p>比如发送时间超过 15000ms 则在 600000 ms 内无法向该 Broker 发送消息。</p>\n<p>这个机制其实很关键，发送超时大概率表明此 Broker 负载高，所以先避让一会儿，让它缓一缓，这也是实现消息发送高可用的关键。</p>\n<p>小结一下</p>\n<ul>\n<li>Producer 每 30s 会向 NameSrv 拉取路由信息更新本地路由表，有新的 Broker 就和其建立长连接，每隔 30s 发送心跳给 Broker 。</li>\n<li>不要在生产环境开启 autoCreateTopicEnable。</li>\n<li>Producer 会通过重试和延迟机制提升消息发送的高可用。</li>\n</ul>\n<h2 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h2><p>        Broker 就比较复杂一些了，但是非常重要。大致分为以下五大模块，我们来看一下官网的图。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/e6bc433478cbf77290bfbaeb72739456.png\"></p>\n<p>Remoting 远程模块，处理客户请求。Client Manager 管理客户端，维护订阅的主题。Store Service 提供消息存储查询服务。HA Serivce，主从同步高可用。Index Serivce，通过指定key 建立索引，便于查询。有几个模块没啥可说的就不分析了，先看看存储的。</p>\n<h3 id=\"Broker-的存储\"><a href=\"#Broker-的存储\" class=\"headerlink\" title=\"Broker 的存储\"></a>Broker 的存储</h3><p>        RocketMQ 存储用的是本地文件存储系统，效率高也可靠。</p>\n<p>主要涉及到三种类型的文件，分别是 CommitLog、ConsumeQueue、IndexFile。</p>\n<h4 id=\"CommitLog\"><a href=\"#CommitLog\" class=\"headerlink\" title=\"CommitLog\"></a>CommitLog</h4><p>        RocketMQ 的所有主题的消息都存在 CommitLog 中，单个 CommitLog 默认 1G，并且文件名以起始偏移量命名，固定 20 位，不足则前面补 0，比如 00000000000000000000 代表了第一个文件，第二个文件名就是 00000000001073741824，表明起始偏移量为 1073741824，以这样的方式命名用偏移量就能找到对应的文件。</p>\n<p>        所有消息都是顺序写入的，超过文件大小则开启下一个文件。</p>\n<h4 id=\"ConsumeQueue\"><a href=\"#ConsumeQueue\" class=\"headerlink\" title=\"ConsumeQueue\"></a>ConsumeQueue</h4><p>        ConsumeQueue 消息消费队列，可以认为是 CommitLog 中消息的索引，因为 CommitLog 是糅合了所有主题的消息，所以通过索引才能更加高效的查找消息。</p>\n<p>        ConsumeQueue 存储的条目是固定大小，只会存储 8 字节的 commitlog 物理偏移量，4 字节的消息长度和 8 字节 Tag 的哈希值，固定 20 字节。</p>\n<p>        在实际存储中，ConsumeQueue 对应的是一个Topic 下的某个 Queue，每个文件约 5.72M，由 30w 条数据组成。</p>\n<p>        消费者是先从 ConsumeQueue 来得到消息真实的物理地址，然后再去 CommitLog 获取消息。</p>\n<h4 id=\"IndexFile\"><a href=\"#IndexFile\" class=\"headerlink\" title=\"IndexFile\"></a>IndexFile</h4><p>        IndexFile 就是索引文件，是额外提供查找消息的手段，不影响主流程。</p>\n<p>        通过 Key 或者时间区间来查询对应的消息，文件名以创建时间戳命名，固定的单个 IndexFile 文件大小约为400M，一个 IndexFile 存储 2000W个索引。</p>\n<p>我们再来看看以上三种文件的内容是如何生成的：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/1569ddeb72bde58035974db8c47245cf.png\"></p>\n<p>        消息到了先存储到 Commitlog，然后会有一个 ReputMessageService 线程接近实时地将消息转发给消息消费队列文件与索引文件，也就是说是异步生成的。</p>\n<h2 id=\"消息刷盘机制\"><a href=\"#消息刷盘机制\" class=\"headerlink\" title=\"消息刷盘机制\"></a>消息刷盘机制</h2><p>        RocketMQ 提供消息同步刷盘和异步刷盘两个选择，关于刷盘我们都知道效率比较低，单纯存入内存中的话效率是最高的，但是可靠性不高，影响消息可靠性的情况大致有以下几种：</p>\n<p>        Broker 被暴力关闭，比如 kill -9Broker 挂了操作系统挂了机器断电机器坏了，开不了机磁盘坏了如果都是 1-4 的情况，同步刷盘肯定没问题，异步的话就有可能丢失部分消息，5 和 6就得依靠副本机制了，如果同步双写肯定是稳的，但是性能太差，如果异步则有可能丢失部分消息。</p>\n<p>所以需要看场景来使用同步、异步刷盘和副本双写机制。</p>\n<h2 id=\"页缓存与内存映射\"><a href=\"#页缓存与内存映射\" class=\"headerlink\" title=\"页缓存与内存映射\"></a>页缓存与内存映射</h2><p>        Commitlog 是混合存储的，所以所有消息的写入就是顺序写入，对文件的顺序写入和内存的写入速度基本上没什么差别。并且 RocketMQ 的文件都利用了内存映射即 Mmap，将程序虚拟页面直接映射到页缓存上，无需有内核态再往用户态的拷贝，来看一下我之前文章画的图。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/8b05f0aeb59b1a2f22bcec96301b84e7.png\"></p>\n<p>        页缓存其实就是操作系统对文件的缓存，用来加速文件的读写，也就是说对文件的写入先写到页缓存中，操作系统会不定期刷盘（时间不可控），对文件的读会先加载到页缓存中，并且根据局部性原理还会预读临近块的内容。其实也是因为使用内存映射机制，所以 RocketMQ 的文件存储都使用定长结构来存储，方便一次将整个文件映射至内存中。</p>\n<h2 id=\"文件预分配和文件预热\"><a href=\"#文件预分配和文件预热\" class=\"headerlink\" title=\"文件预分配和文件预热\"></a>文件预分配和文件预热</h2><p>        而内存映射也只是做了映射，只有当真正读取页面的时候产生缺页中断，才会将数据真正加载到内存中，所以 RocketMQ 做了一些优化，防止运行时的性能抖动。</p>\n<h3 id=\"文件预分配\"><a href=\"#文件预分配\" class=\"headerlink\" title=\"文件预分配\"></a>文件预分配</h3><p>        CommitLog 的大小默认是1G，当超过大小限制的时候需要准备新的文件，而 RocketMQ 就起了一个后台线程 AllocateMappedFileService，不断的处理 AllocateRequest，AllocateRequest 其实就是预分配的请求，会提前准备好下一个文件的分配，防止在消息写入的过程中分配文件，产生抖动。</p>\n<h3 id=\"文件预热\"><a href=\"#文件预热\" class=\"headerlink\" title=\"文件预热\"></a>文件预热</h3><p>        有一个 warmMappedFile 方法，它会把当前映射的文件，每一页遍历多去，写入一个0字节，然后再调用mlock 和 madvise(MADV_WILLNEED)。</p>\n<ul>\n<li>mlock：可以将进程使用的部分或者全部的地址空间锁定在物理内存中，防止其被交换到 swap 空间。</li>\n<li>madvise：给操作系统建议，说这文件在不久的将来要访问的，因此，提前读几页可能是个好主意。</li>\n</ul>\n<p>小结一下</p>\n<ul>\n<li>CommitLog 采用混合型存储，也就是所有 Topic 都存在一起，顺序追加写入，文件名用起始偏移量命名。</li>\n<li>消息先写入 CommitLog 再通过后台线程分发到 ConsumerQueue 和 IndexFile 中。</li>\n<li>消费者先读取 ConsumerQueue 得到真正消息的物理地址，然后访问 CommitLog 得到真正的消息。</li>\n<li>利用了 mmap 机制减少一次拷贝，利用文件预分配和文件预热提高性能。</li>\n<li>提供同步和异步刷盘，根据场景选择合适的机制。</li>\n</ul>\n<h2 id=\"Broker-的-HA\"><a href=\"#Broker-的-HA\" class=\"headerlink\" title=\"Broker 的 HA\"></a>Broker 的 HA</h2><p>        从 Broker 会和主 Broker 建立长连接，然后获取主 Broker commitlog 最大偏移量，开始向主 Broker 拉取消息，主 Broker 会返回一定数量的消息，循环进行，达到主从数据同步。</p>\n<p>        消费者消费消息会先请求主 Broker ，如果主 Broker 觉得现在压力有点大，则会返回从 Broker 拉取消息的建议，然后消费者就去从服务器拉取消息。</p>\n<h2 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h2><p>消费有两种模式，分别是广播模式和集群模式。</p>\n<ul>\n<li>广播模式：一个分组下的每个消费者都会消费完整的Topic 消息。</li>\n<li>集群模式：一个分组下的消费者瓜分消费Topic 消息。</li>\n</ul>\n<p>一般我们用的都是集群模式。</p>\n<p>        而消费者消费消息又分为推和拉模式，详细看我这篇文章消息队列推拉模式，分别从源码级别分析了 RokcetMQ 和 Kafka 的消息推拉，以及推拉模式的优缺点。</p>\n<h3 id=\"Consumer-端的负载均衡机制\"><a href=\"#Consumer-端的负载均衡机制\" class=\"headerlink\" title=\"Consumer 端的负载均衡机制\"></a>Consumer 端的负载均衡机制</h3><p>        Consumer 会定期的获取 Topic 下的队列数，然后再去查找订阅了该 Topic 的同一消费组的所有消费者信息，默认的分配策略是类似分页排序分配。</p>\n<p>        将队列排好序，然后消费者排好序，比如队列有 9 个，消费者有 3 个，那消费者-1 消费队列 0、1、2 的消息，消费者-2 消费队列 3、4、5，以此类推。</p>\n<p>        所以如果负载太大，那么就加队列，加消费者，通过负载均衡机制就可以感知到重平衡，均匀负载。</p>\n<h3 id=\"Consumer-消息消费的重试\"><a href=\"#Consumer-消息消费的重试\" class=\"headerlink\" title=\"Consumer 消息消费的重试\"></a>Consumer 消息消费的重试</h3><p>        难免会遇到消息消费失败的情况，所以需要提供消费失败的重试，而一般的消费失败要么就是消息结构有误，要么就是一些暂时无法处理的状态，所以立即重试不太合适。</p>\n<p>        RocketMQ 会给每个消费组都设置一个重试队列，Topic 是 %RETRY%+consumerGroup，并且设定了很多重试级别来延迟重试的时间。</p>\n<p>        为了利用 RocketMQ 的延时队列功能，重试的消息会先保存在 Topic 名称为“SCHEDULE_TOPIC_XXXX”的延迟队列，在消息的扩展字段里面会存储原来所属的 Topic 信息。</p>\n<p>        delay 一段时间后再恢复到重试队列中，然后 Consumer 就会消费这个重试队列主题，得到之前的消息。</p>\n<p>        如果超过一定的重试次数都消费失败，则会移入到死信队列，即 Topic %DLQ%“ + ConsumerGroup 中，存储死信队列即认为消费成功，因为实在没辙了，暂时放过。</p>\n<p>然后我们可以通过人工来处理死信队列的这些消息。</p>\n<h2 id=\"消息的全局顺序和局部顺序\"><a href=\"#消息的全局顺序和局部顺序\" class=\"headerlink\" title=\"消息的全局顺序和局部顺序\"></a>消息的全局顺序和局部顺序</h2><p>        全局顺序就是消除一切并发，一个 Topic 一个队列，Producer 和 Consuemr 的并发都为一。局部顺序其实就是指某个队列顺序，多队列之间还是能并行的。</p>\n<p>        可以通过 MessageQueueSelector 指定 Producer 某个业务只发这一个队列，然后 Comsuer 通过MessageListenerOrderly 接受消息，其实就是加锁消费。</p>\n<p>        在 Broker 会有一个 mqLockTable ，顺序消息在创建拉取消息任务的时候需要在 Broker 锁定该消息队列，之后加锁成功的才能消费。</p>\n<p>        而严格的顺序消息其实很难，假设现在都好好的，如果有个 Broker 宕机了，然后发生了重平衡，队列对应的消费者实例就变了，就会有可能会出现乱序的情况，如果要保持严格顺序，那此时就只能让整个集群不可用了。</p>\n<h2 id=\"一些注意点\"><a href=\"#一些注意点\" class=\"headerlink\" title=\"一些注意点\"></a>一些注意点</h2><p>1、订阅消息是以 ConsumerGroup 为单位存储的，所以ConsumerGroup 中的每个 Consumer 需要有相同的订阅。</p>\n<p>        因为订阅消息是随着心跳上传的，如果一个 ConsumerGroup 中 Consumer 订阅信息不一样，那么就会出现互相覆盖的情况。</p>\n<p>        比如消费者 A 订阅 Topic a，消费者 B 订阅 Topic b，此时消费者 A 去 Broker 拿消息，然后 B 的心跳包发出了，Broker 更新了，然后接到 A 的请求，一脸懵逼，没这订阅关系啊。</p>\n<p>2、RocketMQ 主从读写分离</p>\n<p>        从只能读，不能写，并且只有当前客户端读的 offset 和 当前 Broker 已接受的最大 offset 超过限制的物理内存大小时候才会去从读，所以正常情况下从分担不了流量。</p>\n<p>3、单单加机器提升不了消费速度，队列的数量也需要跟上。</p>\n<p>4、之前提到的，不要允许自动创建主题</p>\n<h2 id=\"RocketMQ-的最佳实践\"><a href=\"#RocketMQ-的最佳实践\" class=\"headerlink\" title=\"RocketMQ 的最佳实践\"></a>RocketMQ 的最佳实践</h2><p>这些最佳实践部分参考自官网。</p>\n<p>Tags的使用</p>\n<p>        建议一个应用一个 Topic，利用 tages 来标记不同业务，因为 tages 设置比较灵活，且一个应用一个 Topic 很清晰，能直观的辨别。</p>\n<p>Keys的使用</p>\n<p>        如果有消息业务上的唯一标识，请填写到 keys 字段中，方便日后的定位查找。</p>\n<h2 id=\"提高-Consumer-的消费能力\"><a href=\"#提高-Consumer-的消费能力\" class=\"headerlink\" title=\"提高 Consumer 的消费能力\"></a>提高 Consumer 的消费能力</h2><p>1、提高消费并行度：增加队列数和消费者数量，提高单个消费者的并行消费线程，参数 consumeThreadMax。</p>\n<p>2、批处理消费，设置 consumeMessageBatchMaxSize 参数，这样一次能拿到多条消息，然后比如一个 update语句之前要执行十次，现在一次就执行完。</p>\n<p>3、跳过非核心的消息，当负载很重的时候，为了保住那些核心的消息，设置那些非核心的消息，例如此时消息堆积 1W 条了之后，就直接返回消费成功，跳过非核心消息。</p>\n<h2 id=\"NameServer-的寻址\"><a href=\"#NameServer-的寻址\" class=\"headerlink\" title=\"NameServer 的寻址\"></a>NameServer 的寻址</h2><p>请使用 HTTP 静态服务器寻址（默认），这样 NameServer 就能动态发现。</p>\n<h2 id=\"JVM选项\"><a href=\"#JVM选项\" class=\"headerlink\" title=\"JVM选项\"></a>JVM选项</h2><p>以下抄自官网：</p>\n<p>        如果不关心 RocketMQ Broker的启动时间，通过“预触摸” Java 堆以确保在 JVM 初始化期间每个页面都将被分配。</p>\n<p>        那些不关心启动时间的人可以启用它：-XX:+AlwaysPreTouch禁用偏置锁定可能会减少JVM暂停， -XX:-UseBiasedLocking至于垃圾回收，建议使用带JDK 1.8的G1收集器。</p>\n<p>        -XX:+UseG1GC -XX:G1HeapRegionSize&#x3D;16m-XX:G1ReservePercent&#x3D;25-XX:InitiatingHeapOccupancyPercent&#x3D;30</p>\n<p>        另外不要把-XX:MaxGCPauseMillis的值设置太小，否则JVM将使用一个小的年轻代来实现这个目标，这将导致非常频繁的minor GC，所以建议使用rolling GC日志文件:</p>\n<p>        -XX:+UseGCLogFileRotation-XX:NumberOfGCLogFiles&#x3D;5-XX:GCLogFileSize&#x3D;30m</p>\n<h2 id=\"Linux内核参数\"><a href=\"#Linux内核参数\" class=\"headerlink\" title=\"Linux内核参数\"></a>Linux内核参数</h2><p>以下抄自官网：</p>\n<ul>\n<li>vm.extra_free_kbytes，告诉VM在后台回收（kswapd）启动的阈值与直接回收（通过分配进程）的阈值之间保留额外的可用内存。RocketMQ使用此参数来避免内存分配中的长延迟。（与具体内核版本相关）</li>\n<li>vm.min_free_kbytes，如果将其设置为低于1024KB，将会巧妙的将系统破坏，并且系统在高负载下容易出现死锁。</li>\n<li>vm.max_map_count，限制一个进程可能具有的最大内存映射区域数。RocketMQ将使用mmap加载CommitLog和ConsumeQueue，因此建议将为此参数设置较大的值。（agressiveness –&gt; aggressiveness）</li>\n<li>vm.swappiness，定义内核交换内存页面的积极程度。较高的值会增加攻击性，较低的值会减少交换量。建议将值设置为10来避免交换延迟。</li>\n<li>File descriptor limits，RocketMQ需要为文件（CommitLog和ConsumeQueue）和网络连接打开文件描述符。我们建议设置文件描述符的值为655350。</li>\n<li>Disk scheduler，RocketMQ建议使用I&#x2F;O截止时间调度器，它试图为请求提供有保证的延迟。</li>\n</ul>\n<p>Article link： <a href=\"https://tqgoblin.site/post/csdn/RocketMQ%E4%BB%8B%E7%BB%8D/\">https://tqgoblin.site/post/csdn/RocketMQ介绍/</a> <div align=left> Author：<a href=\"https://www.tqgoblin.site\"> Stephen </a> </div></p>\n","text":"RocketMQ 整体架构设计 整体的架构设计主要分为四大部分，分别是：Producer、Consumer、Broker、NameServer。 为了更贴合实际...","permalink":"/post/csdn/RocketMQ介绍","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"mq","slug":"mq","count":5,"path":"api/categories/mq.json"}],"tags":[{"name":"面试 面试 java-rocketmq","slug":"面试-面试-java-rocketmq","count":1,"path":"api/tags/面试-面试-java-rocketmq.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RocketMQ-%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">RocketMQ 整体架构设计</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NameServer\"><span class=\"toc-text\">NameServer</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Producer\"><span class=\"toc-text\">Producer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Producer-%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Producer 启动流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Producer-%E5%8F%91%E6%B6%88%E6%81%AF%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">Producer 发消息流程</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E4%B8%BB%E9%A2%98%E7%9A%84%E5%BC%8A%E7%AB%AF\"><span class=\"toc-text\">自动创建主题的弊端</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8F%91%E9%80%81%E6%B6%88%E6%81%AF%E6%95%85%E9%9A%9C%E5%BB%B6%E8%BF%9F%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">发送消息故障延迟机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Broker\"><span class=\"toc-text\">Broker</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Broker-%E7%9A%84%E5%AD%98%E5%82%A8\"><span class=\"toc-text\">Broker 的存储</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CommitLog\"><span class=\"toc-text\">CommitLog</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ConsumeQueue\"><span class=\"toc-text\">ConsumeQueue</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#IndexFile\"><span class=\"toc-text\">IndexFile</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E5%88%B7%E7%9B%98%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">消息刷盘机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E7%BC%93%E5%AD%98%E4%B8%8E%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">页缓存与内存映射</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E9%A2%84%E5%88%86%E9%85%8D%E5%92%8C%E6%96%87%E4%BB%B6%E9%A2%84%E7%83%AD\"><span class=\"toc-text\">文件预分配和文件预热</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E9%A2%84%E5%88%86%E9%85%8D\"><span class=\"toc-text\">文件预分配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E9%A2%84%E7%83%AD\"><span class=\"toc-text\">文件预热</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Broker-%E7%9A%84-HA\"><span class=\"toc-text\">Broker 的 HA</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Consumer\"><span class=\"toc-text\">Consumer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Consumer-%E7%AB%AF%E7%9A%84%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">Consumer 端的负载均衡机制</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Consumer-%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9%E7%9A%84%E9%87%8D%E8%AF%95\"><span class=\"toc-text\">Consumer 消息消费的重试</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E7%9A%84%E5%85%A8%E5%B1%80%E9%A1%BA%E5%BA%8F%E5%92%8C%E5%B1%80%E9%83%A8%E9%A1%BA%E5%BA%8F\"><span class=\"toc-text\">消息的全局顺序和局部顺序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E4%BA%9B%E6%B3%A8%E6%84%8F%E7%82%B9\"><span class=\"toc-text\">一些注意点</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RocketMQ-%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">RocketMQ 的最佳实践</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8F%90%E9%AB%98-Consumer-%E7%9A%84%E6%B6%88%E8%B4%B9%E8%83%BD%E5%8A%9B\"><span class=\"toc-text\">提高 Consumer 的消费能力</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NameServer-%E7%9A%84%E5%AF%BB%E5%9D%80\"><span class=\"toc-text\">NameServer 的寻址</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#JVM%E9%80%89%E9%A1%B9\"><span class=\"toc-text\">JVM选项</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Linux%E5%86%85%E6%A0%B8%E5%8F%82%E6%95%B0\"><span class=\"toc-text\">Linux内核参数</span></a></li></ol>","author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"如何更好地使用Kafka","uid":"af845c075b322bafbf0dd249cd968eb7","slug":"csdn/如何更好地使用Kafka","date":"2022-12-01T09:31:05.000Z","updated":"2025-02-17T04:32:37.063Z","comments":true,"path":"api/articles/csdn/如何更好地使用Kafka.json","keywords":"Stephen web3","cover":"../img/1c8d68e9dec35793796ea26cf1f6a419.jpg","text":"引言 要确保Kafka在使用过程中的稳定性，需要从kafka在业务中的使用周期进行依次保障。主要可以分为：事先预防（通过规范的使用、开发，预防问题产生）、运行时...","permalink":"/post/csdn/如何更好地使用Kafka","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"mq","slug":"mq","count":5,"path":"api/categories/mq.json"}],"tags":[{"name":"kafka java 大数据","slug":"kafka-java-大数据","count":1,"path":"api/tags/kafka-java-大数据.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"RocketMQ与kafka的区别","uid":"a66c39428303def8c1769f2fae79ffad","slug":"csdn/RocketMQ与kafka的区别","date":"2022-11-10T09:13:06.000Z","updated":"2025-02-17T04:32:55.070Z","comments":true,"path":"api/articles/csdn/RocketMQ与kafka的区别.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/blog/bimg/68db4265-fa19-408a-81bc-d8ebed6537db.jpg","text":"一、前言 淘宝内部的交易系统使用了淘宝自主研发的Notify消息中间件，使用MySQL作为消息存储媒介，支持水平扩容。为了进一步降低成本，阿里中间件团队认为No...","permalink":"/post/csdn/RocketMQ与kafka的区别","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"mq","slug":"mq","count":5,"path":"api/categories/mq.json"}],"tags":[{"name":"面试 kafka 面试","slug":"面试-kafka-面试","count":1,"path":"api/tags/面试-kafka-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}