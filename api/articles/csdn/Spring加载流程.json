{"title":"Spring加载流程","uid":"92e817b0edbefb52af49230332579af2","slug":"csdn/Spring加载流程","date":"2022-10-18T08:43:29.000Z","updated":"2025-02-17T01:58:21.598Z","comments":true,"path":"api/articles/csdn/Spring加载流程.json","keywords":"Stephen web3","cover":[],"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><span id=\"more\"></span>\n\n<p><strong>一、spring加载流程</strong></p>\n<p>        tomcat在启动ServletContext容器的时候会发布ServletContextEvent事件，Spring就通过实现ServletContextListener接口，<a href=\"https://so.csdn.net/so/search?q=%E7%9B%91%E5%90%AC&spm=1001.2101.3001.7020\" title=\"监听\">监听</a>该事件来监听ServletContext的生命周期。web.<a href=\"https://so.csdn.net/so/search?q=xml&spm=1001.2101.3001.7020\" title=\"xml\">xml</a>中配置了ContextLoaderListener实现了ServletContextListener接口。对ServletContext启动监听，在initWebApplicationContext方法中会通过ServletContext获取web.xml中配置的contextConfigLocation参数值，也就是spring的xml配置<img src=\"https://i-blog.csdnimg.cn/blog_migrate/d220ab9fedf5c6c28aa5532736a97044.png\"></p>\n<p>然后会调用SpringIOC容器refresh()方法初始化容器：</p>\n<p>        refresh 是 AbstractApplicationContext 中的一个方法，负责初始化 ApplicationContext 容器，容器必须调用 refresh 才能正常工作。它的内部主要会调用 12 个方法，我们把它们称为 refresh 的 12 个步骤：</p>\n<ol>\n<li>prepareRefresh：<ol>\n<li><p>一开始设置启动时间及开启启动标识</p>\n</li>\n<li><p>Environment 对象的作用之一是为后续 @Value，值注入时提供键值</p>\n</li>\n<li><p>保存 java 环境键值、保存系统环境键值、保存自定义键值</p>\n</li>\n</ol>\n</li>\n<li>obtainFreshBeanFactory<ol>\n<li><p>这一步获取(或创建）BeanFactory，BeanFactory 的作用是负责 bean 的创建、依赖注入和初始化，bean 的各项特征由 BeanDefinition 定义</p>\n</li>\n<li><p>BeanDefinition 作为 bean 的设计蓝图，规定了 bean 的特征，如单例多例、依赖关系、初始销毁方法等</p>\n</li>\n<li><p>所有的 BeanDefinition 会存入 BeanFactory 中的 beanDefinitionMap 集合</p>\n</li>\n<li><p>BeanDefinition 的来源有多种多样，可以是通过 xml 获得、配置类获得、组件扫描获得，也可以是编程添加</p>\n</li>\n</ol>\n</li>\n<li>prepareBeanFactory<ol>\n<li>这一步会进一步完善 BeanFactory，为它的各项成员变量赋值，并应用 ApplicationContext 提供的 Environment 完成 ${ } 解析</li>\n</ol>\n</li>\n<li>postProcessBeanFactory<ol>\n<li><p>这一步是空实现，留给子类扩展。</p>\n</li>\n<li><p>一般 Web 环境的 ApplicationContext 都要利用它注册新的 Scope，完善 Web 下的 BeanFactory</p>\n</li>\n<li><p>这里体现的是模板方法设计模式</p>\n</li>\n</ol>\n</li>\n<li>invokeBeanFactoryPostProcessors<ol>\n<li><p>这一步会调用 beanFactory 后处理器</p>\n</li>\n<li><p>beanFactory 后处理器，充当 beanFactory 的扩展点，可以用来补充或修改 BeanDefinition</p>\n</li>\n<li><p>常见的 beanFactory 后处理器有：ConfigurationClassPostProcessor – 解析 @Configuration、@Bean、@Import、@PropertySource 等；PropertySourcesPlaceHolderConfigurer – 替换 BeanDefinition 中的 ${ }；MapperScannerConfigurer – 补充 Mapper 接口对应的 BeanDefinition。</p>\n</li>\n</ol>\n</li>\n<li>registerBeanPostProcessors<ol>\n<li><p>这一步是继续从 beanFactory 中找出 bean 后处理器，添加至 beanPostProcessors 集合中</p>\n</li>\n<li><p>bean 后处理器，充当 bean 的扩展点，可以工作在 bean 的实例化、依赖注入、初始化阶段，常见的有：AutowiredAnnotationBeanPostProcessor 功能有：解析 @Autowired，@Value 注解；CommonAnnotationBeanPostProcessor 功能有：解析 @Resource，@PostConstruct，@PreDestroy；AnnotationAwareAspectJAutoProxyCreator 功能有：为符合切点的目标 bean 自动创建代理。</p>\n</li>\n</ol>\n</li>\n<li>initMessageSource<ol>\n<li><p>这一步是为 ApplicationContext 添加 messageSource 成员，实现国际化功能</p>\n</li>\n<li><p>去 beanFactory 内找名为 messageSource 的 bean，如果没有，则提供空的 MessageSource 实现</p>\n</li>\n</ol>\n</li>\n<li>initApplicationEventMulticaster<ol>\n<li><p>这一步为 ApplicationContext 添加事件广播器成员，即 applicationContextEventMulticaster，它的作用是发布事件给监听器</p>\n</li>\n<li><p>去 beanFactory 找名为 applicationEventMulticaster 的 bean 作为事件广播器，若没有，会创建默认的事件广播器</p>\n</li>\n</ol>\n</li>\n<li>onRefresh<ol>\n<li><p>这一步是空实现，留给子类扩展</p>\n</li>\n<li><p>SpringBoot 中的子类在这里准备了 WebServer，即内嵌 web 容器</p>\n</li>\n<li><p>体现的是模板方法设计模式</p>\n</li>\n</ol>\n</li>\n<li>registerListeners<br>1.  这一步会从多种途径找到事件监听器，并添加至 applicationEventMulticaster用来接收事件广播器发布的事件</li>\n</ol>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">2.  有如下来源：事先编程添加的；来自容器中的 bean；来自于 \\@EventListener 的解析；要实现事件监听器，只需要实现 ApplicationListener 接口，重写其中 onApplicationEvent\\(E e\\) 方法即可；</span></span></code></pre></div><ol start=\"11\">\n<li>finishBeanFactoryInitialization<br>1.  这一步会将 beanFactory 的成员补充完毕，并初始化所有非延迟单例 bean</li>\n</ol>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">2.  singletonObjects 即单例池，缓存所有单例对象</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">3.  对象的创建都分三个阶段，每一阶段都有不同的 bean 后处理器参与进来，扩展功能</span></span></code></pre></div><ol start=\"12\">\n<li>finishRefresh<br>1.  这一步会为 ApplicationContext 添加 lifecycleProcessor 成员，用来控制容器内需要生命周期管理的 bean</li>\n</ol>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #babed8\">2.  如果容器中有名称为 lifecycleProcessor 的 bean 就用它，否则创建默认的生命周期管理器</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">3.  准备好生命周期管理器，就可以实现</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">4.  调用 context 的 start，即可触发所有实现 LifeCycle 接口 bean 的 start。调用 context 的 stop，即可触发所有实现 LifeCycle 接口 bean 的 stop。</span></span>\n<span class=\"line\"><span style=\"color: #babed8\"></span></span>\n<span class=\"line\"><span style=\"color: #babed8\">5.  发布 ContextRefreshed 事件，整个 refresh 执行完成</span></span></code></pre></div><p>其中：</p>\n<p>1 为准备环境</p>\n<p>2 3 4 5 6 为准备 BeanFactory</p>\n<p>7 8 9 10 12 为准备 ApplicationContext</p>\n<p>11 为初始化 BeanFactory 中非延迟单例 bean</p>\n<p>Exception（异常情况）</p>\n<p>        如果过程中出现异常走到这里销毁所有创建的单例bean,AtomicBoolean active标识false.最后清除所有缓存及类加载资源<img src=\"https://i-blog.csdnimg.cn/blog_migrate/b6af263ceef2317fce7dc2f423bed769.png\"><img src=\"https://i-blog.csdnimg.cn/blog_migrate/13f5fe0f39332111e9f829a7470ff11b.png\"> </p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/6ecf03c68c8996f05fbb468520caf8aa.png\"></p>\n<p>Article link： <a href=\"https://tqgoblin.site/post/csdn/Spring%E5%8A%A0%E8%BD%BD%E6%B5%81%E7%A8%8B/\">https://tqgoblin.site/post/csdn/Spring加载流程/</a> <div align=left> Author：<a href=\"https://www.tqgoblin.site\"> Stephen </a> </div></p>\n","text":" 一、spring加载流程 tomcat在启动ServletContext容器的时候会发布ServletContextEvent事件，Spring就通过实现Se...","permalink":"/post/csdn/Spring加载流程","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"spring spring java 面试","slug":"spring-spring-java-面试","count":1,"path":"api/tags/spring-spring-java-面试.json"}],"toc":"","author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"HashMap底层原理","uid":"5c0f27a0ed8d73f08892501931e4fc3a","slug":"csdn/HashMap底层原理","date":"2022-10-18T08:56:52.000Z","updated":"2025-02-17T01:58:21.594Z","comments":true,"path":"api/articles/csdn/HashMap底层原理.json","keywords":"Stephen web3","cover":[],"text":" 一、HashMap特点：数组＋链表存储数据 线理不安全 默认数组大小16，2倍扩容，扩容因子0.75 HashMap 基于键 HashCode 值唯一标识一条...","permalink":"/post/csdn/HashMap底层原理","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"java","slug":"java","count":6,"path":"api/categories/java.json"}],"tags":[{"name":"面试 java","slug":"面试-java","count":1,"path":"api/tags/面试-java.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"springMVC介绍","uid":"98cffa2ec843f93b7a73d616ab307ba8","slug":"csdn/springMVC介绍","date":"2022-10-18T06:59:27.000Z","updated":"2025-02-17T01:58:21.599Z","comments":true,"path":"api/articles/csdn/springMVC介绍.json","keywords":"Stephen web3","cover":[],"text":" 一、springmvc初始化 我们使用springMVC的时候，它的主要入口时dispatcherServlet类，它最终实现了Servlet接口。Servl...","permalink":"/post/csdn/springMVC介绍","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"spring","slug":"spring","count":1,"path":"api/categories/spring.json"}],"tags":[{"name":"面试 java spring","slug":"面试-java-spring","count":1,"path":"api/tags/面试-java-spring.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}