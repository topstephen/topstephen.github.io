{"title":"RocketMQ与kafka的区别","uid":"a66c39428303def8c1769f2fae79ffad","slug":"csdn/RocketMQ与kafka的区别","date":"2022-11-10T09:13:06.000Z","updated":"2025-02-17T04:32:55.070Z","comments":true,"path":"api/articles/csdn/RocketMQ与kafka的区别.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/blog/bimg/68db4265-fa19-408a-81bc-d8ebed6537db.jpg","content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"一、前言\"><a href=\"#一、前言\" class=\"headerlink\" title=\"一、前言\"></a>一、前言</h2><p>        淘宝内部的交易系统使用了淘宝自主研发的Notify消息中间件，使用MySQL作为消息存储媒介，支持水平扩容。为了进一步降低成本，阿里中间件团队认为Notify可进一步优化。</p>\n<p>        2011年初，Linkedin开源了kafka, 阿里中间件团队在对kafka做了充分的review之后，被kafka的无限消息堆积能力、高效的持久化速度深深吸引，但同时发现kafka主要定位于日志传输，对于使用在淘宝交易、订单、充值等场景下，还有若干特性不满足。因此，阿里中间件团队基于Java重新编写了RocketMQ，定位于不仅限于日志场景的可靠消息传输。</p>\n<p>        目前，RocketMQ在阿里集团被广泛应用于订单、充值、交易、流计算、消息推送、日志流式处理、binlog分发等场景。</p>\n<h2 id=\"二、RocketMQ与kafka的不同\"><a href=\"#二、RocketMQ与kafka的不同\" class=\"headerlink\" title=\"二、RocketMQ与kafka的不同\"></a>二、RocketMQ与kafka的不同</h2><h3 id=\"1、数据可靠性\"><a href=\"#1、数据可靠性\" class=\"headerlink\" title=\"1、数据可靠性\"></a>1、数据可靠性</h3><p>RocketMQ：支持异步实时刷盘、同步刷盘、同步复制、异步复制。<br>kafka：使用异步刷盘方式，异步复制&#x2F;同步复制。</p>\n<p>总结：<br>1、RocketMQ支持kafka所不具备的“同步刷盘”功能，在单机可靠性上比kafka更高，不会因为操作系统Crash而导致数据丢失。<br>2、kafka的同步replication理论上性能低于RocketMQ的replication，这是因为kafka的数据以partition为单位，这样一个kafka实例上可能多上百个partition。而一个RocketMQ实例上只有一个partition，RocketMQ可以充分利用IO组的commit机制，批量传输数据。同步replication与异步replication相比，同步replication性能上损耗约20%-30%。</p>\n<p>一句话概括：RocketMQ新增了同步刷盘机制，保证了可靠性；一个RocketMQ实例只有一个partition, 在replication时性能更好。</p>\n<h3 id=\"2、性能对比\"><a href=\"#2、性能对比\" class=\"headerlink\" title=\"2、性能对比\"></a>2、性能对比</h3><p>1、kafka单机写入TPS月在百万条&#x2F;秒，消息大小为10个字节。<br>2、RocketMQ单机写入TPS单实例约7万条&#x2F;秒，若单机部署3个broker，可以跑到最高12万条&#x2F;秒，消息大小为10个字节。</p>\n<p>总结：<br>kafka的单机TPS能跑到每秒上百万，是因为Producer端将多个小消息合并，批量发向broker。</p>\n<p>那么RocketMQ为什么没有这样做呢？</p>\n<p>发送消息的Producer通常是用Java语言，缓存过多消息，GC是个很严重的问题。（问题：难道kafka用scala不需要GC？）<br>Producer发送消息到broker, 若消息发送出去后，未达到broker，就通知业务消息发送成功，若此时Broker宕机，则会导致消息丢失，从而导致业务出错。<br>Producer通常为分布式系统，且每台机器都是多线程发送，通常来说线上单Producer产生的消息数量不会过万。<br>消息合并功能完全可由上层业务来做。<br>一句话概括：<strong>RocketMQ写入性能上不如kafka, 主要因为kafka主要应用于日志场景，而RocketMQ应用于业务场景，为了保证消息必达牺牲了性能，且基于线上真实场景没有在RocketMQ层做消息合并，推荐在业务层自己做。</strong></p>\n<h3 id=\"3、单机支持的队列数\"><a href=\"#3、单机支持的队列数\" class=\"headerlink\" title=\"3、单机支持的队列数\"></a>3、单机支持的队列数</h3><p>1、kafka单机若超过了64个partition&#x2F;队列，CPU load会发生明显飙高，partition越多，CPU load越高，发消息的响应时间变长。<br>2、RocketMQ单机支持最高5万个队列，CPU load不会发生明显变化。</p>\n<p>队列多有什么好处呢？<br>1、单机可以创建更多个topic, 因为每个topic都是有一组队列组成。<br>2、消费者的集群规模和队列数成正比，队列越多，消费类集群可以越大。</p>\n<p>一句话概括：RocketMQ支持的队列数远高于kafka支持的partition数，这样RocketMQ可以支持更多的consumer集群。</p>\n<h3 id=\"4、消息投递的实时性\"><a href=\"#4、消息投递的实时性\" class=\"headerlink\" title=\"4、消息投递的实时性\"></a>4、消息投递的实时性</h3><p>1、kafka采用短轮询的方式，实时性取决于轮询时间间隔，0.8以后版本支持长轮询。<br>2、RocketMQ使用长轮询，同Push实时性一致，消息投递的延迟通常在几毫秒内，</p>\n<p>一句话：<strong>kafka与RocketMQ都支持长轮询，消息投递的延迟在几毫秒内。</strong></p>\n<h3 id=\"5、消费失败重试\"><a href=\"#5、消费失败重试\" class=\"headerlink\" title=\"5、消费失败重试\"></a>5、消费失败重试</h3><p>1、kafka不支持消费失败重试。<br>2、RocketMQ消费失败支持定时重试，每次重试间隔时间顺延。</p>\n<p>总结：以充值类应用为例，若当前时刻调用运营商网管失败，可能运营商网关此时压力过大，稍后再调用就会成功。这里的重试指可靠的重试，即失败重试的消息不是因为consumer宕机而导致的消息丢失。</p>\n<p>一句话概括：<strong>RocketMQ支持消费失败重试功能，主要用于第一次调用不成功，后面可调用成功的场景。而kafka不支持消费失败重试。</strong></p>\n<h3 id=\"6、严格保证消息有序\"><a href=\"#6、严格保证消息有序\" class=\"headerlink\" title=\"6、严格保证消息有序\"></a>6、严格保证消息有序</h3><p>1、kafka可保证同一个partition上的消息有序，但一旦broker宕机，就会产生消息乱序。<br>2、Rocket支持严格的消息顺序，一台broker宕机，发送消息会失败，但不会乱序。举例：MySQL的二进制日志分发需要保证严格的顺序。</p>\n<p>一句话概括：<strong>kafka不保证消息有序，RocketMQ可保证严格的消息顺序，即使单台Broker宕机，仅会造成消息发送失败，但不会消息乱序。</strong></p>\n<h3 id=\"7、定时消息\"><a href=\"#7、定时消息\" class=\"headerlink\" title=\"7、定时消息\"></a>7、定时消息</h3><p>1、kafka不支持定时消息<br>2、开源版本的RocketMQ仅支持定时级别，定时级别用户可定制</p>\n<h3 id=\"8、分布式事务消息\"><a href=\"#8、分布式事务消息\" class=\"headerlink\" title=\"8、分布式事务消息\"></a>8、分布式事务消息</h3><p>1、kafka不支持分布式事务消息<br>2、RocketMQ支持分布式事务消息。</p>\n<h3 id=\"9、消息查询\"><a href=\"#9、消息查询\" class=\"headerlink\" title=\"9、消息查询\"></a>9、消息查询</h3><p>1、kafka不支持消息查询<br>2、RocketMQ支持根据消息标识（发送消息时指定一个消息key, 任意字符串，如指定为订单编号）查询消息，也支持根据消息内容查询消息。</p>\n<p>总结：消息查询功能对于定位消息丢失问题非常有用，例如某个订单处理失败，可用此功能查询是消息没收到，还是收到了但处理出错了。</p>\n<p>一句话概括：<strong>RocketMQ支持按消息标识或消息内容查询消息，用于排查消息丢失问题；kafka不支持消息查询。</strong></p>\n<h3 id=\"10、消息回溯\"><a href=\"#10、消息回溯\" class=\"headerlink\" title=\"10、消息回溯\"></a>10、消息回溯</h3><p>1、kafka可按照消息的offset来回溯消息<br>2、RocketMQ支持按照时间来回溯消息，精度到毫秒，例如从一天的几点几分几秒几毫秒来重新消费消息。</p>\n<p>总结：RocketMQ按时间做回溯消息的典型应用场景为，consumer做订单分析，但是由于程序逻辑或依赖的系统发生故障等原因，导致今天处理的消息全部无效，需要从昨天的零点重新处理。</p>\n<h3 id=\"11、消息并行度\"><a href=\"#11、消息并行度\" class=\"headerlink\" title=\"11、消息并行度\"></a>11、消息并行度</h3><p>1、kafka的消息并行度，依赖于topic里配置的partition数，如果partition数为10，那么最多10台机器来消费，每台机器只能开启一个线程；或者一台机器消费，最多开启10个线程。消费的并行度与partition个数一致。<br>2、RocketMQ并行消费分两种情况：<br>1）顺序消费方式的并行度与kafka一致。<br>2）乱序消费方式的并行度取决于consumer的线程数，如topic配置10个队列，10台机器消费，每台机器100个线程，那么并行度为1000。</p>\n<p>一句话概括：<strong>kafka的消费并行度等于partition数；RocketMQ的消费并行度等于消费的线程数，不受队列数限制。</strong></p>\n<h3 id=\"12、开发语言\"><a href=\"#12、开发语言\" class=\"headerlink\" title=\"12、开发语言\"></a>12、开发语言</h3><p>1、kafka采用scala开发<br>2、RocketMQ采用Java开发</p>\n<h3 id=\"13、消息堆积能力\"><a href=\"#13、消息堆积能力\" class=\"headerlink\" title=\"13、消息堆积能力\"></a>13、消息堆积能力</h3><p>kafka比RocketMQ的消息堆积能力更强，不过RocketMQ单机也可支持亿级的消息积压能力，这个堆积能力也能够完全满足业务需求。</p>\n<h3 id=\"14、开源社区活跃度\"><a href=\"#14、开源社区活跃度\" class=\"headerlink\" title=\"14、开源社区活跃度\"></a>14、开源社区活跃度</h3><p>1、kafka社区更新较慢<br>2、RocketMQ的Github社区有250人，公司用户登记了联系方式，QQ群超过1000人，<br>3、kafka原开发团队成立了新公司，暂时未看到相关产品。<br>4、RocketMQ已在阿里云商业化，目前以云服务形式供外部商用，并向用户承诺99.99%的可靠性，同时彻底解决了用户自己搭建MQ产品的运维复杂性问题。</p>\n<h3 id=\"15、应用领域成熟度\"><a href=\"#15、应用领域成熟度\" class=\"headerlink\" title=\"15、应用领域成熟度\"></a>15、应用领域成熟度</h3><p>1、kafka在日志领域比较成熟<br>2、RocketMQ在阿里集团内部有大量的应用在使用，并顺利支持了多次天猫双十一的考验。</p>\n<h2 id=\"三、总结\"><a href=\"#三、总结\" class=\"headerlink\" title=\"三、总结\"></a>三、总结</h2><p>kafka和RocketMQ的总体区别是，kafka设计初衷是用于日志传输，而RocketMQ的设计用于解决各类应用可靠的消息传输，阿里云官网承诺RocketMQ数据可靠性为10个9，服务可靠性为99.95%。</p>\n<p>kafka相比RocketMQ的优势<br>1、单机吞吐量TPS可上百万，远高于RocketMQ的TPS7万每秒，适用于日志类消息。<br>2、kafka支持多语言的客户端</p>\n<p>RocketMQ相比kafka的优势<br>**1、保证消息不丢（ 数据可靠性达10个9）<br>2、可严格保证消息有序<br>3、支持分布式事务消息<br>4、支持按时间做消息回溯（可精确到毫秒级）<br>5、支持按标识和内容查询消息，用于排查丢消息<br>6、支持消费失败重试<br>7、可支持更多的partition, 即更多的消费线程数<br>————————————————<br>版权声明：本文为CSDN博主「Shi Peng」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href=\"https://blog.csdn.net/shijinghan1126/article/details/104724407\">https://blog.csdn.net/shijinghan1126/article/details/104724407</a></p>\n<p>Article link： <a href=\"https://tqgoblin.site/post/csdn/RocketMQ%E4%B8%8Ekafka%E7%9A%84%E5%8C%BA%E5%88%AB/\">https://tqgoblin.site/post/csdn/RocketMQ与kafka的区别/</a> <div align=left> Author：<a href=\"https://www.tqgoblin.site\"> Stephen </a> </div></p>\n","text":"一、前言 淘宝内部的交易系统使用了淘宝自主研发的Notify消息中间件，使用MySQL作为消息存储媒介，支持水平扩容。为了进一步降低成本，阿里中间件团队认为No...","permalink":"/post/csdn/RocketMQ与kafka的区别","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"mq","slug":"mq","count":5,"path":"api/categories/mq.json"}],"tags":[{"name":"面试 kafka 面试","slug":"面试-kafka-面试","count":1,"path":"api/tags/面试-kafka-面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">一、前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81RocketMQ%E4%B8%8Ekafka%E7%9A%84%E4%B8%8D%E5%90%8C\"><span class=\"toc-text\">二、RocketMQ与kafka的不同</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1%E3%80%81%E6%95%B0%E6%8D%AE%E5%8F%AF%E9%9D%A0%E6%80%A7\"><span class=\"toc-text\">1、数据可靠性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2%E3%80%81%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94\"><span class=\"toc-text\">2、性能对比</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3%E3%80%81%E5%8D%95%E6%9C%BA%E6%94%AF%E6%8C%81%E7%9A%84%E9%98%9F%E5%88%97%E6%95%B0\"><span class=\"toc-text\">3、单机支持的队列数</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4%E3%80%81%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E7%9A%84%E5%AE%9E%E6%97%B6%E6%80%A7\"><span class=\"toc-text\">4、消息投递的实时性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5%E3%80%81%E6%B6%88%E8%B4%B9%E5%A4%B1%E8%B4%A5%E9%87%8D%E8%AF%95\"><span class=\"toc-text\">5、消费失败重试</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6%E3%80%81%E4%B8%A5%E6%A0%BC%E4%BF%9D%E8%AF%81%E6%B6%88%E6%81%AF%E6%9C%89%E5%BA%8F\"><span class=\"toc-text\">6、严格保证消息有序</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7%E3%80%81%E5%AE%9A%E6%97%B6%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">7、定时消息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8%E3%80%81%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">8、分布式事务消息</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9%E3%80%81%E6%B6%88%E6%81%AF%E6%9F%A5%E8%AF%A2\"><span class=\"toc-text\">9、消息查询</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#10%E3%80%81%E6%B6%88%E6%81%AF%E5%9B%9E%E6%BA%AF\"><span class=\"toc-text\">10、消息回溯</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#11%E3%80%81%E6%B6%88%E6%81%AF%E5%B9%B6%E8%A1%8C%E5%BA%A6\"><span class=\"toc-text\">11、消息并行度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#12%E3%80%81%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80\"><span class=\"toc-text\">12、开发语言</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#13%E3%80%81%E6%B6%88%E6%81%AF%E5%A0%86%E7%A7%AF%E8%83%BD%E5%8A%9B\"><span class=\"toc-text\">13、消息堆积能力</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#14%E3%80%81%E5%BC%80%E6%BA%90%E7%A4%BE%E5%8C%BA%E6%B4%BB%E8%B7%83%E5%BA%A6\"><span class=\"toc-text\">14、开源社区活跃度</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#15%E3%80%81%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F%E6%88%90%E7%86%9F%E5%BA%A6\"><span class=\"toc-text\">15、应用领域成熟度</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">三、总结</span></a></li></ol>","author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"RocketMQ介绍","uid":"23a83ea7b13859971f6150dc36d3dd3b","slug":"csdn/RocketMQ介绍","date":"2022-11-10T09:36:17.000Z","updated":"2025-02-17T04:31:59.814Z","comments":true,"path":"api/articles/csdn/RocketMQ介绍.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/UTOOLS1577681541276.jpg","text":"RocketMQ 整体架构设计 整体的架构设计主要分为四大部分，分别是：Producer、Consumer、Broker、NameServer。 为了更贴合实际...","permalink":"/post/csdn/RocketMQ介绍","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"mq","slug":"mq","count":5,"path":"api/categories/mq.json"}],"tags":[{"name":"面试 面试 java-rocketmq","slug":"面试-面试-java-rocketmq","count":1,"path":"api/tags/面试-面试-java-rocketmq.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"kafka的rebalance机制","uid":"4a7935236206ce0c80a1379bd98b2262","slug":"csdn/kafka的rebalance机制","date":"2022-11-10T08:01:25.000Z","updated":"2025-02-17T04:35:04.466Z","comments":true,"path":"api/articles/csdn/kafka的rebalance机制.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/blog/bimg/toolbagShader.png","text":"一、Reblance是什么 Reblance就像他的名称一样，意思是再平衡，平衡什么？平衡消费者和分区之间的对应关系。本质上来讲，Reblance是一种协议，规...","permalink":"/post/csdn/kafka的rebalance机制","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"kafka kafka 面试","slug":"kafka-kafka-面试","count":1,"path":"api/tags/kafka-kafka-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}