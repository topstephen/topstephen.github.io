{"title":"如何排查java程序导致的cpu和内存过高异常","uid":"f003f641d410fd391760b84b742d0677","slug":"csdn/如何排查java程序导致的cpu和内存过高异常","date":"2022-10-09T06:32:40.000Z","updated":"2025-02-17T04:22:34.809Z","comments":true,"path":"api/articles/csdn/如何排查java程序导致的cpu和内存过高异常.json","keywords":"Stephen web3","cover":[],"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"引言\"><a href=\"#引言\" class=\"headerlink\" title=\"引言\"></a>引言</h2><p>Java程序在实际生产过程中经常遇到CPU或内存使用率高的问题，那么应该如何排查问题的原因呢，本文大概描述一下排查方法。</p>\n<h2 id=\"一、命令方式分析\"><a href=\"#一、命令方式分析\" class=\"headerlink\" title=\"一、命令方式分析\"></a>一、命令方式分析</h2><h3 id=\"1-排查占用CPU的进程\"><a href=\"#1-排查占用CPU的进程\" class=\"headerlink\" title=\"1.排查占用CPU的进程\"></a>1.排查占用CPU的进程</h3><ul>\n<li>使用top命令，在大写打开的情况下按P键或者在大写没有打开的情况下按 shift+P键，会按照CPU使用率的高低进行排序（在大写打开的情况下按M键或者在大写没有打开的情况下按 shift+M键，会按照内存使用率的高低进行排序），查找使用率最高的进程获取进程PID。<img src=\"https://i-blog.csdnimg.cn/blog_migrate/22cec0e27a19dd7a496552931418c81f.png\"></li>\n</ul>\n<h3 id=\"2-查找实际占用最高的线程\"><a href=\"#2-查找实际占用最高的线程\" class=\"headerlink\" title=\"2.查找实际占用最高的线程\"></a>2.查找实际占用最高的线程</h3><ul>\n<li>使用命令top -H -p PID,此处PID就是上一步获取的进程PID，通过此命令可以查看实际占用CPU最高的的线程的ID，此处几位TID<img src=\"https://i-blog.csdnimg.cn/blog_migrate/6edc119c756a1dcabad79174bb72d2c2.png\"></li>\n</ul>\n<h3 id=\"3-获取对应线程的线程栈信息\"><a href=\"#3-获取对应线程的线程栈信息\" class=\"headerlink\" title=\"3.获取对应线程的线程栈信息\"></a>3.获取对应线程的线程栈信息</h3><ul>\n<li>使用命令printf “%x\\n” tid，将线程ID转换为16进制</li>\n<li>使用命令jstack PID(进程pid) |grep tid(线程pid16进制) -A 50，此处tid为上一步转换后的16进制，使用此命令可以查看到对应线程的线程栈信息，从对根据线程栈对对应的代码进行分析<img src=\"https://i-blog.csdnimg.cn/blog_migrate/7efa3d1496a9d4ea0d95d729be5d16fd.png\"></li>\n</ul>\n<h2 id=\"二、dump文件分析\"><a href=\"#二、dump文件分析\" class=\"headerlink\" title=\"二、dump文件分析\"></a>二、dump文件分析</h2><h3 id=\"1-dump文件输出\"><a href=\"#1-dump文件输出\" class=\"headerlink\" title=\"1.dump文件输出\"></a>1.dump文件输出</h3><ul>\n<li>输出dump文件方式一：jmap -dump:live,format&#x3D;b,file&#x3D;aaa.dump pid</li>\n<li>输出dump文件方式二：jcmd pid GC.heap_dump smpo1.dump</li>\n<li>内存溢出输出dump:     -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath&#x3D;路径</li>\n</ul>\n<p>注：命令直接复制可能执行报未找到命令的话就手敲</p>\n<h3 id=\"2-可视化工具分析\"><a href=\"#2-可视化工具分析\" class=\"headerlink\" title=\"2.可视化工具分析\"></a>2.可视化工具分析</h3><p>之后用dump分析工具打开分析堆栈信息，比如jdk自带的jvisualvm</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/59c293a271eb650137b6dbbeec5353a9.png\"></p>\n<p>Article link： <a href=\"https://tqgoblin.site/post/csdn/%E5%A6%82%E4%BD%95%E6%8E%92%E6%9F%A5java%E7%A8%8B%E5%BA%8F%E5%AF%BC%E8%87%B4%E7%9A%84cpu%E5%92%8C%E5%86%85%E5%AD%98%E8%BF%87%E9%AB%98%E5%BC%82%E5%B8%B8/\">https://tqgoblin.site/post/csdn/如何排查java程序导致的cpu和内存过高异常/</a> <div align=left> Author：<a href=\"https://www.tqgoblin.site\"> Stephen </a> </div></p>\n","text":"引言Java程序在实际生产过程中经常遇到CPU或内存使用率高的问题，那么应该如何排查问题的原因呢，本文大概描述一下排查方法。 一、命令方式分析1.排查占用CPU...","permalink":"/post/csdn/如何排查java程序导致的cpu和内存过高异常","photos":[],"count_time":{"symbolsCount":828,"symbolsTime":"1 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"Java linux jvm","slug":"Java-linux-jvm","count":1,"path":"api/tags/Java-linux-jvm.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%95%E8%A8%80\"><span class=\"toc-text\">引言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81%E5%91%BD%E4%BB%A4%E6%96%B9%E5%BC%8F%E5%88%86%E6%9E%90\"><span class=\"toc-text\">一、命令方式分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E6%8E%92%E6%9F%A5%E5%8D%A0%E7%94%A8CPU%E7%9A%84%E8%BF%9B%E7%A8%8B\"><span class=\"toc-text\">1.排查占用CPU的进程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%9F%A5%E6%89%BE%E5%AE%9E%E9%99%85%E5%8D%A0%E7%94%A8%E6%9C%80%E9%AB%98%E7%9A%84%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">2.查找实际占用最高的线程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E8%8E%B7%E5%8F%96%E5%AF%B9%E5%BA%94%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A0%88%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">3.获取对应线程的线程栈信息</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81dump%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90\"><span class=\"toc-text\">二、dump文件分析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-dump%E6%96%87%E4%BB%B6%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">1.dump文件输出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E5%8F%AF%E8%A7%86%E5%8C%96%E5%B7%A5%E5%85%B7%E5%88%86%E6%9E%90\"><span class=\"toc-text\">2.可视化工具分析</span></a></li></ol></li></ol>","author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Java阻塞队列","uid":"32c93abe435d8f794f6c98ee11259476","slug":"csdn/Java阻塞队列","date":"2022-10-10T09:52:53.000Z","updated":"2025-02-17T04:22:34.793Z","comments":true,"path":"api/articles/csdn/Java阻塞队列.json","keywords":"Stephen web3","cover":[],"text":"概述 队列是种只允许在表的前端进行删除操作，而在表的后端进行插入操作的线性表。阻塞队列和一般队列的不同之处在于阻塞队列是“阻塞”的，这里的阻塞指的是操作队 列的...","permalink":"/post/csdn/Java阻塞队列","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"Kafka中怎么保证消息不会丢失和不重复消费？","uid":"80846fe2badad166d0ce9fff99b0e646","slug":"csdn/Kafka中怎么保证消息不会丢失和不重复消费？","date":"2022-10-09T02:53:10.000Z","updated":"2025-02-17T04:22:34.725Z","comments":true,"path":"api/articles/csdn/Kafka中怎么保证消息不会丢失和不重复消费？.json","keywords":"Stephen web3","cover":[],"text":"从两个方面分析：消息推送和消息消费。也就是生产者和消费者两方面。首先我们需要知道topic的概念。 Topic ： 话题，可以理解为一个队列， 生产者和消费者面...","permalink":"/post/csdn/Kafka中怎么保证消息不会丢失和不重复消费？","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"mq","slug":"mq","count":5,"path":"api/categories/mq.json"}],"tags":[{"name":"kafka","slug":"kafka","count":1,"path":"api/tags/kafka.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}