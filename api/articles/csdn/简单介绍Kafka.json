{"title":"简单介绍Kafka","uid":"65befa2e81f1cf5d027b510d356d0eda","slug":"csdn/简单介绍Kafka","date":"2022-10-13T15:38:26.000Z","updated":"2025-02-17T04:22:34.820Z","comments":true,"path":"api/articles/csdn/简单介绍Kafka.json","keywords":"Stephen web3","cover":[],"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><h2 id=\"Kafka-概念\"><a href=\"#Kafka-概念\" class=\"headerlink\" title=\"Kafka 概念\"></a><strong>Kafka</strong> <strong>概念</strong></h2><p>Kafka 是一种高吞吐量、分布式、基于发布&#x2F;订阅的消息系统，最初由 LinkedIn 公司开发，使用Scala 语言编写，目前是 Apache 的开源项目。</p>\n<ol>\n<li>broker：Kafka 服务器，负责消息存储和转发</li>\n<li> topic：消息类别，Kafka 按照 topic 来分类消息</li>\n<li>partition：topic 的分区，一个 topic 可以包含多个 partition，topic 消息保存在各个 partition 上</li>\n<li>offset：消息在日志中的位置，可以理解是消息在 partition 上的偏移量，也是代表该消息的唯一序号</li>\n<li> Producer：消息生产者</li>\n<li>Consumer：消息消费者</li>\n<li>Consumer Group：消费者分组，每个 Consumer 必须属于一个 group</li>\n<li> Zookeeper：保存着集群 broker、topic、partition 等 meta 数据；另外，还负责 broker 故障发现，partition leader 选举，负载均衡等功能</li>\n</ol>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/6ba40f6cc38096696775b465c3d5934e.png\"></p>\n<h2 id=\"一、Kafka-数据存储设计\"><a href=\"#一、Kafka-数据存储设计\" class=\"headerlink\" title=\"一、Kafka 数据存储设计\"></a><strong>一、Kafka</strong> <strong>数据存储设计</strong></h2><h3 id=\"1-partition-的数据文件（offset，MessageSize，data）\"><a href=\"#1-partition-的数据文件（offset，MessageSize，data）\" class=\"headerlink\" title=\"1.partition 的数据文件（offset，MessageSize，data）\"></a><strong>1.partition 的数据文件（<strong><strong>offset，MessageSize，data</strong></strong>）</strong></h3><p>        partition 中的每条 Message 包含了以下三个属性：offset，MessageSize，data，其中 offset 表示 Message 在这个 partition 中的偏移量，offset 不是该 Message 在 partition 数据文件中的实际存储位置，而是逻辑上一个值，它唯一确定了 partition 中的一条 Message，可以认为 offset 是partition 中 Message 的 id；MessageSize 表示消息内容 data 的大小；data 为 Message 的具体内容。</p>\n<h3 id=\"2-数据文件分段-segment（顺序读写、分段命令、二分查找）\"><a href=\"#2-数据文件分段-segment（顺序读写、分段命令、二分查找）\" class=\"headerlink\" title=\"2.数据文件分段 segment（顺序读写、分段命令、二分查找）\"></a><strong>2.数据文件分段 segment（<strong><strong>顺序读写、分段命令、二分查找</strong></strong>）</strong></h3><p>partition 物理上由多个 segment 文件组成，每个 segment 大小相等，顺序读写。每个segment 数据文件以该段中最小的 offset 命名，文件扩展名为.log。这样在查找指定 offset 的Message 的时候，用二分查找就可以定位到该 Message 在哪个 segment 数据文件中。</p>\n<h3 id=\"3-数据文件索引（分段索引、稀疏存储）\"><a href=\"#3-数据文件索引（分段索引、稀疏存储）\" class=\"headerlink\" title=\"3.数据文件索引（分段索引、稀疏存储）\"></a><strong>3.数据文件索引（分段索引、<strong><strong>稀疏存储</strong></strong>）</strong></h3><p>        Kafka 为每个分段后的数据文件建立了索引文件，文件名与数据文件的名字是一样的，只是文件扩 展名为.index。index 文件中并没有为数据文件中的每条 Message 建立索引，而是采用了稀疏存储的方式，每隔一定字节的数据建立一条索引。这样避免了索引文件占用过多的空间，从而可以将索引文件保留在内存中。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/06fbe27cf897e0188c78bfc54f866c04.png\"></p>\n<h2 id=\"三、生产者设计\"><a href=\"#三、生产者设计\" class=\"headerlink\" title=\"三、生产者设计\"></a>三、<strong>生产者设计</strong></h2><h3 id=\"1-负载均衡（partition-会均衡分布到不同-broker-上）\"><a href=\"#1-负载均衡（partition-会均衡分布到不同-broker-上）\" class=\"headerlink\" title=\"1.负载均衡（partition 会均衡分布到不同 broker 上）\"></a>1.<strong>负载均衡（partition 会均衡分布到不同 broker 上）</strong></h3><p>        由于消息 topic 由多个 partition 组成， 且 partition 会均衡分布到不同 broker 上，因此，为了有效利用 broker 集群的性能，提高消息的吞吐量 ，producer 可以通过随机或者 hash 等方式，将消息平均发送到多个 partition 上，以实现负载均衡。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/84c91a4b0796fdff969881c7292410cc.png\"></p>\n<h3 id=\"2-批量发送\"><a href=\"#2-批量发送\" class=\"headerlink\" title=\"2.批量发送\"></a>2.<strong>批量发送</strong></h3><p>        是提高消息吞吐量重要的方式，Producer 端可以在内存中合并多条消息后， 以一次请求的方式发送了批量的消息给 broker ，从而大大减少 broker 存储消息的 IO 操作次数。但也一定程度上影响了消息的实时性，相当于以时延代价，换取更好的吞吐量。</p>\n<h3 id=\"3-压缩（GZIP-或-Snappy）\"><a href=\"#3-压缩（GZIP-或-Snappy）\" class=\"headerlink\" title=\"3. 压缩（GZIP 或 Snappy）\"></a><strong>3. 压缩（<strong><strong>GZIP 或 Snappy</strong></strong>）</strong></h3><p>        Producer 端可以通过 GZIP 或 Snappy 格式对消息集合进行压缩。Producer 端进行压缩之后，在Consumer 端需进行解压。压缩的好处就是减少传输的数据量，减轻对网络传输的压力，在对大数据处理上，瓶颈往往体现在网络上而不是 CPU（压缩和解压会耗掉部分CPU 资源）。</p>\n<h2 id=\"三、消费者设计\"><a href=\"#三、消费者设计\" class=\"headerlink\" title=\"三、消费者设计\"></a><strong>三、消费者设计</strong></h2><p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/eb363750446d8213d1b4059ab132ca8b.png\"></p>\n<h3 id=\"1-Consumer-Group\"><a href=\"#1-Consumer-Group\" class=\"headerlink\" title=\"1. Consumer Group\"></a><strong>1. Consumer Group</strong></h3><p>        同一 Consumer Group 中的多个 Consumer 实例，不同时消费同一个 partition，等效于队列模式。partition 内消息是有序的，Consumer 通过 pull 方式消费消息。Kafka 不删除已消费的消息 对于 partition，顺序读写磁盘数据，以时间复杂度 O(1)方式提供消息持久化能力。</p>\n<p>Article link： <a href=\"https://tqgoblin.site/post/csdn/%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8DKafka/\">https://tqgoblin.site/post/csdn/简单介绍Kafka/</a> <div align=left> Author：<a href=\"https://www.tqgoblin.site\"> Stephen </a> </div></p>\n","text":"Kafka 概念Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由 LinkedIn 公司开发，使用Scala 语言编写，目前是 Apache...","permalink":"/post/csdn/简单介绍Kafka","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"kafka kafka","slug":"kafka-kafka","count":1,"path":"api/tags/kafka-kafka.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Kafka-%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">Kafka 概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81Kafka-%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">一、Kafka 数据存储设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-partition-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%EF%BC%88offset%EF%BC%8CMessageSize%EF%BC%8Cdata%EF%BC%89\"><span class=\"toc-text\">1.partition 的数据文件（offset，MessageSize，data）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E5%88%86%E6%AE%B5-segment%EF%BC%88%E9%A1%BA%E5%BA%8F%E8%AF%BB%E5%86%99%E3%80%81%E5%88%86%E6%AE%B5%E5%91%BD%E4%BB%A4%E3%80%81%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%89\"><span class=\"toc-text\">2.数据文件分段 segment（顺序读写、分段命令、二分查找）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E6%95%B0%E6%8D%AE%E6%96%87%E4%BB%B6%E7%B4%A2%E5%BC%95%EF%BC%88%E5%88%86%E6%AE%B5%E7%B4%A2%E5%BC%95%E3%80%81%E7%A8%80%E7%96%8F%E5%AD%98%E5%82%A8%EF%BC%89\"><span class=\"toc-text\">3.数据文件索引（分段索引、稀疏存储）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E7%94%9F%E4%BA%A7%E8%80%85%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">三、生产者设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%88partition-%E4%BC%9A%E5%9D%87%E8%A1%A1%E5%88%86%E5%B8%83%E5%88%B0%E4%B8%8D%E5%90%8C-broker-%E4%B8%8A%EF%BC%89\"><span class=\"toc-text\">1.负载均衡（partition 会均衡分布到不同 broker 上）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81\"><span class=\"toc-text\">2.批量发送</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-%E5%8E%8B%E7%BC%A9%EF%BC%88GZIP-%E6%88%96-Snappy%EF%BC%89\"><span class=\"toc-text\">3. 压缩（GZIP 或 Snappy）</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81%E6%B6%88%E8%B4%B9%E8%80%85%E8%AE%BE%E8%AE%A1\"><span class=\"toc-text\">三、消费者设计</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-Consumer-Group\"><span class=\"toc-text\">1. Consumer Group</span></a></li></ol></li></ol>","author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"java中的锁","uid":"1c003f281cf294408d7d24cc6188aa8e","slug":"csdn/java中的锁","date":"2022-10-14T15:40:19.000Z","updated":"2025-02-17T04:33:33.329Z","comments":true,"path":"api/articles/csdn/java中的锁.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/blog/bimg/68db4265-fa19-408a-81bc-d8ebed6537db.jpg","text":"1. 乐观锁 VS 悲观锁乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。 先说概念。对于同一个数...","permalink":"/post/csdn/java中的锁","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"锁 java 面试","slug":"锁-java-面试","count":1,"path":"api/tags/锁-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"java并发关键字","uid":"f00905d171c4323a2676ba94b49d2b6c","slug":"csdn/java并发关键字","date":"2022-10-11T03:27:15.000Z","updated":"2025-02-17T04:22:34.733Z","comments":true,"path":"api/articles/csdn/java并发关键字.json","keywords":"Stephen web3","cover":[],"text":"一、CountDownLatch CountDownLatch类位于java.util.concurrent包下，是一个同步工具类 ，允许一个或多个线程一直等待...","permalink":"/post/csdn/java并发关键字","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"Java 面试 java","slug":"Java-面试-java","count":1,"path":"api/tags/Java-面试-java.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}