{"title":"什么是AQS","uid":"7d9db4929e21c0d91333dbdc28b79909","slug":"csdn/什么是AQS","date":"2022-10-10T15:35:06.000Z","updated":"2025-02-17T04:22:34.715Z","comments":true,"path":"api/articles/csdn/什么是AQS.json","keywords":"Stephen web3","cover":[],"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><p>        AQS ( Abstract Queued Synchronizer ）是一个抽象的队列同步器，通过维护一个共享资源状态（ Volatile Int State ）和一个先进先出（ FIFO ）的线程等待队列来实现一个多线程访问共享资源的同步框架。</p>\n<h2 id=\"一、AQS原理\"><a href=\"#一、AQS原理\" class=\"headerlink\" title=\"一、AQS原理\"></a>一、AQS原理</h2><p>         AQS 为每个共享资源都设置一个共享资源锁，线程在需要访问共享资源时首先需要获取共享资源锁，如果获取到了共享资源锁，便可以在当前线程中使用该共享资源，如果获取不到，则将该线程放入线程等待队列，等待下一次资源调度，具体的流程如图 -14所示。许多同步类的实现都依赖于AQS ，例如常用的 ReentrantLock、Semaphore、CountDownLatch。</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/4d52e35da411b2cb3bcbd10bcf34e6fc.png\"></p>\n<p> </p>\n<h2 id=\"二、state：状态\"><a href=\"#二、state：状态\" class=\"headerlink\" title=\"二、state：状态\"></a>二、state：状态</h2><p>        Abstract Queued Synchronizer 维护了 volatile int 类型的变量，用于表示当前的同步状态。volatile虽然不能保证操作的原子性，但是能保证当前变量state的可见性。<br>        state的访问方式有三种： getState()、setState()和 compareAndSetState()，均是原子操作，其中，compareAndSetState的实现依赖于 Unsafe的compareAndSwaplnt() 具体的。JDK 码实现如下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/164ec5913a7274c1f3a34bd4d6b20e1e.png\"></p>\n<h2 id=\"三、AQS共享资源的方式：独占式和共享式\"><a href=\"#三、AQS共享资源的方式：独占式和共享式\" class=\"headerlink\" title=\"三、AQS共享资源的方式：独占式和共享式\"></a>三、AQS共享资源的方式：独占式和共享式</h2><p>        AQS 定义了两种资源共享方式 ：独占式 (Exclusive)和共享式(Share)</p>\n<ul>\n<li>独占式:只有一个线程能执行，具体的 Java 实现有 ReentrantLock。</li>\n<li>共享式：多个线程可同时执行，具体的 Java 实现有 Semaphore和CountDownLatch。</li>\n</ul>\n<p>        AQS只是一个框架 ，只定义了一个接口，具体资源的获取、释放都 由自定义同步器去实现。不同的自定义同步器争用共享资源的方式也不同，自定义同步器在实现时只需实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护，如获取资源失败入队、唤醒出队等， AQS 已经在顶层实现好，不需要具体的同步器再做处理。自定义同步器的主要方法如表 3-4 所示:</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/e0c78b85c83ddf92927c52077ae88e20.png\"></p>\n<p>        同步器的实现是 AQS的核心内存。 ReentrantLock对AQS的独占方式实现为：ReentrantLock中的state初始值为0表示无锁状态。在线程执行 tryAcquire()获取该锁后ReentrantLock中的state+1，这时该线程独占ReentrantLock锁，其他线程在通过tryAcquire() 获取锁时均会失败，直到该线程释放锁后state再次为0，其他线程才有机会获取该锁。该线程在释放锁之前可以重复获取此锁，每获取一次便会执行一次state+1, 因此ReentrantLock也属于可重入锁。 但获取多少次锁就要释放多少次锁，这样才能保证state最终为0。如果获取锁的次数多于释放锁的次数，则会出现该线程一直持有该锁的情况；如果获取锁的次数少于释放锁的次数，则运行中的程序会报锁异常。<br>        CountDownLatch对AQS的共享方式实现为：CountDownLatch 将任务分为N个子线程去执行，将 state 初始化为 N, N与线程的个数一致，N个子线程是井行执行的，每个子线程都在执行完成后 countDown()1次， state 执行 CAS 操作并减1。在所有子线程都执行完成( state&#x3D;O)时会unpark()主线程，然后主线程会从 await()返回，继续执行后续的动作。</p>\n<p>        一般来说，自定义同步器要么采用独占方式，要么采用共享方式 ，实现类只需实现tryAcquire、tryseAcquireShared、tryReleaseShared 中的一组即可。但AQS也支持自定义同步器同时实现独占和共享两种方式，例如 ReentrantReadWriteLock 在读取时采用了共享方式，在写入时采用了独占方式。</p>\n<p>Article link： <a href=\"https://tqgoblin.site/post/csdn/%E4%BB%80%E4%B9%88%E6%98%AFAQS/\">https://tqgoblin.site/post/csdn/什么是AQS/</a> <div align=left> Author：<a href=\"https://www.tqgoblin.site\"> Stephen </a> </div></p>\n","text":" AQS ( Abstract Queued Synchronizer ）是一个抽象的队列同步器，通过维护一个共享资源状态（ Volatile Int Stat...","permalink":"/post/csdn/什么是AQS","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"面试 java 面试","slug":"面试-java-面试","count":1,"path":"api/tags/面试-java-面试.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81AQS%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">一、AQS原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81state%EF%BC%9A%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">二、state：状态</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81AQS%E5%85%B1%E4%BA%AB%E8%B5%84%E6%BA%90%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9A%E7%8B%AC%E5%8D%A0%E5%BC%8F%E5%92%8C%E5%85%B1%E4%BA%AB%E5%BC%8F\"><span class=\"toc-text\">三、AQS共享资源的方式：独占式和共享式</span></a></li></ol>","author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"java并发关键字","uid":"f00905d171c4323a2676ba94b49d2b6c","slug":"csdn/java并发关键字","date":"2022-10-11T03:27:15.000Z","updated":"2025-02-17T04:22:34.733Z","comments":true,"path":"api/articles/csdn/java并发关键字.json","keywords":"Stephen web3","cover":[],"text":"一、CountDownLatch CountDownLatch类位于java.util.concurrent包下，是一个同步工具类 ，允许一个或多个线程一直等待...","permalink":"/post/csdn/java并发关键字","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"Java 面试 java","slug":"Java-面试-java","count":1,"path":"api/tags/Java-面试-java.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"什么是 CAS","uid":"2a388c0d390bb47b986af930ed26f977","slug":"csdn/什么是 CAS","date":"2022-10-10T14:58:41.000Z","updated":"2025-02-17T04:22:34.834Z","comments":true,"path":"api/articles/csdn/什么是 CAS.json","keywords":"Stephen web3","cover":[],"text":"一、CAS 的概念：比较并交换 CAS (Compare And Swap）指比较并交换。CAS算法 CAS(V,E,N)包含3个参数，V表示要更新的变量，E表...","permalink":"/post/csdn/什么是 CAS","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"Java java 面试","slug":"Java-java-面试","count":1,"path":"api/tags/Java-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}