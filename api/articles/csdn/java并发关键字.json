{"title":"java并发关键字","uid":"f00905d171c4323a2676ba94b49d2b6c","slug":"csdn/java并发关键字","date":"2022-10-11T03:27:15.000Z","updated":"2025-02-17T01:58:21.607Z","comments":true,"path":"api/articles/csdn/java并发关键字.json","keywords":"Stephen web3","cover":[],"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><span id=\"more\"></span>\n\n<h2 id=\"一、CountDownLatch\"><a href=\"#一、CountDownLatch\" class=\"headerlink\" title=\"一、CountDownLatch\"></a>一、CountDownLatch</h2><p>        CountDownLatch类位于java.util.concurrent包下，是一个同步工具类 ，允许一个或多个线程一直等待其他线程的操作执行完后再执行相关操作。<br>        CountDownLatch 基于线程计数器来实现并发访问控制，主要用于主线程等待其他子线程都执行完毕后执行相关操作。其使用过程为：在主线程中定义CountDownLatch，并将线程计数器的初始值设置为子线程的个数，多个子线程并发执行，每个子线程在执行完毕后都会调用countDown函数将计数器的值减1，直到线程计数器为0，表示所有的子线程任务都已执行完毕， 此时countDownLatch上等待的主线程将被唤醒并继续执行。<br>        我们利用CountDownLatch可以实现类似计数器的功能 比如有一个主任务，它要等待其他两个任务都执行完毕之后才能执行，此时就可以利用 CountDownLatch来实现这种功能。具体实现如下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/aba2e8184d196f688e5e4131974ecdbc.png\"></p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/f6d8f866d72ba3210a6a15ce95da4404.png\"> </p>\n<p>        以上代码片段先定义了一个大小为2的CountDownLatch，然后定义了两个子线程并启动该子线程，子线程执行完业务代码后在执行latch.countDown()时减少一个信号量，表示自己已执行完成。 主线程调用latch.await()阻塞等待，在所有线程都执行完成并调用了countDown函数时， 表示所有线程均执行完成，这时程序会主动唤醒主线程井开始执行主线程的业务逻辑。</p>\n<h2 id=\"二、CyclicBarrier\"><a href=\"#二、CyclicBarrier\" class=\"headerlink\" title=\"二、CyclicBarrier\"></a>二、CyclicBarrier</h2><p>        CyclicBarrier （循环屏障）是一个同步工具，可以实现让一组线程等待至某个状态之后再全部同时执行。 在所有等待线程都被释放之后，CyclicBarrier 可以被重用。CyclicBarrer的运行状态叫作Barrier状态，在调用 await方法后，线程就处于Barrier状态。<br>        CyclicBarrier中最重要的方法是 await 方法，它有两种实现。</p>\n<ul>\n<li>public int await()：挂起当前线程直到所有线程都为 Barrier 状态再同时执行后续的任务。</li>\n<li>public int await(long timeout, Tim Unit unit)：设置一个超时时间，在超时时间过后，如果还有线程未达到 Barrier 状态，则不再等待，让达到 Barrier 态的线程继续执行后续的任务。</li>\n</ul>\n<p>CyclicBarrier的具体使用方法如下：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/211d32ad1252bce650065f39e3122fae.png\"></p>\n<p>        以上代码先定义了一CyclicBarrier， 然后循环启动了多个线程，每个线程都通过构造函数将 CyclicBarrier 传入线程 ，在线程内部开始执行第1阶段的工作，比如查询数据等；等第1阶段的工作处理完成后，再调cyclicBarrier.await 方法等待其他线程也完成第一阶段的工作(CyclicBarrier让一组线程等待到达某个状态再一起执行);等其他线程也执行完第1阶段的工作，便可执行并发操作的下一项任务，比如数据分发等。</p>\n<h2 id=\"三、Semaphore\"><a href=\"#三、Semaphore\" class=\"headerlink\" title=\"三、Semaphore\"></a>三、Semaphore</h2><p>        Semaphore指信号量，用于控制同时访问某些资源的线程个数，具体做法为通过调用acquire()获取一个许可，如果没有许可，则等待，在许可使用完毕后通过 release() 释放该许可，以便其他线程使用。<br>        Semaphore常被用于多线程需要共享有限资源的情况，比如办公室有两台打印机，但是有5个员工需要使用， 一台打印机同时只能被一个员工使用，其他员工排队等候，且只有该打印机被使用完毕并释放后其他员工方可使用，这时就可以通过Semaphore来实现：<br><img src=\"https://i-blog.csdnimg.cn/blog_migrate/12f1559bb0235f95931127546e4f8cc0.png\"></p>\n<p>        以上代码中首先定义了一个数量为2的Semaphore ，然后定义了一个工作线程Worker并通过构造函数将Semaphore传入到线程内部。在线程调用semaphore.acquire()时开始申请许可并执行业务逻辑，在线程业务逻辑执行完成后调用Semaphore.release()释放许可，以便其他线程使用。</p>\n<p>Semaphore 类中有以下几个比较重要的方法。</p>\n<ul>\n<li>public void acquire ()：以阻塞方式获取一个许可，在有可用许可时返回该许可，在没有可用许可时阻塞等待，直到获得许可。</li>\n<li>public void acquire(int permits)：同时获取permits个许可。</li>\n<li>public void relase ()： 释放某个许可。</li>\n<li>public void release(int permits)： 释放 permits 个许可。</li>\n<li>public boolean try Acquire()：以非阻塞方式获取一个许可，在有可用许可时获取该许可并返回true，否则返回false不会等待。</li>\n<li>public boolean tryAcquire(long timeout,Tim Unit unit）：如果在指定的时间内成功获取到可用许可，则返回true，否则返回false。</li>\n<li>public boolean tryAcquire(int permits ）：如果成功获取 permits 个许可 则返回 true,否则立即返回false。</li>\n<li>public boolean tryAcquire(int permits,long timeout,TimeUnit unit)：如果在指定的时间内成功获取permits个许可，则返回true，否则返回false。</li>\n<li>availablePermits()：查询可用的许可数量。</li>\n</ul>\n<p><strong>CountDownLatch、CyclicBarrier、Semaphore的区别如下。</strong></p>\n<ul>\n<li>CountDownLatch和CyclicBarrier 都用于实现多线程之间的相互等待，但二者的关注点不同。CountDownLatch主要用于主线程等待其他子线程任务均执行完毕后再执行接下来的业务逻辑单元，而CyclicBarrier主要用于一组线程互相等待大家都达到某个状态后，再同时执行接下来的业务逻辑单元。此外，CountDownLatch是不可以重用的，而CyclicBarrier是可以重用的。</li>\n<li>Semaphore和Java中的锁功能类似，主要用于控制资源的并发访问。</li>\n</ul>\n<h2 id=\"四、volatile-关键字的作用\"><a href=\"#四、volatile-关键字的作用\" class=\"headerlink\" title=\"四、volatile 关键字的作用\"></a>四、volatile 关键字的作用</h2><p>        Java 除了使用了synchronized保证变量的同步，还使用了稍弱的同步机制，即volatile变量。 volatile也用于确保将变量的更新操作通知到其他线程。<br>        volatile具备两种特性：一种是保证该变量对所有线程可见，在一个线程修改了变量的值后，新的值对于其他线程是可以立即获取的；一种是volatile禁止指令重排，即volatile 不会被缓存在寄存器中或者对其他处理器不可见的地方，因此在读取volatile类型的变量时总会返回最新写入的值。<br>        因为在访问volatile变量时不会执行加锁操作，也就不会执行线程阻塞，因此volatile 变量是一种比synchronize关键字更轻量级的同步机制。volatile 主要适用于一个变量被多个线程共享，多个线程均可针对这个变量执行赋值或者读取的操作。<br>        在有多个线程对普通变量进行读写时，每个线程都首先需要将数据从内存中复制变量到CPU缓存中，如果计算机有多个CPU，则线程可能都在不同的CPU被处理，这意味着每个线程都需要将同一个数据复制到不同的CPU Cache中，这样在每个线程都针对同一个变量的数据做了不同的处理后就可能存在数据不一致的情况。具体的多线程读写流程如图所示：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/16029791b49c782f57e8ddf9d8fb59ff.png\"></p>\n<p>        如果将变量声明为volatile, JVM就能保证每次读取变量时都直接从内存中读取，跳过CPU Cache这一步 ，有效解决了多线程数据同步的问题。具体的流程如图所示： </p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/2d039a39dc4196c1b33065e28e7e6d77.png\"></p>\n<p>        需要说明的是，volatile关键字可以严格保障变量的单次读、写操作的原子性，但并不能保证像i++这种操作的原子性，因为i++在本质上是读、写两次操作。 volatile在某些场景下可以代替synchronized，但是volatile不能完全取代synchronize的位置，只有在一些特殊场景下才适合使用volatile。比如，必须同时满足下面两个条件才能保证并发环境的线程安全。</p>\n<ul>\n<li>对变量的写操作不依赖于当前值（比如i++），或者说是单纯的变量赋值( boolean flag &#x3D; true)。</li>\n<li>该变量没有被包含在具有其他的不变式中，也就是说在不同的volatile变量之间不能互相依赖，只有在状态真正独立于程序内的其他内容时才能使用volatile。</li>\n</ul>\n<p>        volatile关键字的使用方法比较简单，直接在定义变量时加上volatile关键字即可：</p>\n<div class=\"language-java\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">java</span><pre class=\"shiki material-theme-palenight\" style=\"background-color: #1a1a1a\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #C792EA\">volatile</span><span style=\"color: #BABED8\"> </span><span style=\"color: #C792EA\">boolean</span><span style=\"color: #BABED8\"> flag </span><span style=\"color: #89DDFF\">=</span><span style=\"color: #BABED8\"> </span><span style=\"color: #89DDFF\">false;</span><span style=\"color: #BABED8\"> </span></span></code></pre></div><p>Article link： <a href=\"https://tqgoblin.site/post/csdn/java%E5%B9%B6%E5%8F%91%E5%85%B3%E9%94%AE%E5%AD%97/\">https://tqgoblin.site/post/csdn/java并发关键字/</a> <div align=left> Author：<a href=\"https://www.tqgoblin.site\"> Stephen </a> </div></p>\n","text":" 一、CountDownLatch CountDownLatch类位于java.util.concurrent包下，是一个同步工具类 ，允许一个或多个线程一直等...","permalink":"/post/csdn/java并发关键字","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"并发","slug":"并发","count":1,"path":"api/categories/并发.json"}],"tags":[{"name":"java 面试 java","slug":"java-面试-java","count":1,"path":"api/tags/java-面试-java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81CountDownLatch\"><span class=\"toc-text\">一、CountDownLatch</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81CyclicBarrier\"><span class=\"toc-text\">二、CyclicBarrier</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E3%80%81Semaphore\"><span class=\"toc-text\">三、Semaphore</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9B%9B%E3%80%81volatile-%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">四、volatile 关键字的作用</span></a></li></ol>","author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"简单介绍Kafka","uid":"65befa2e81f1cf5d027b510d356d0eda","slug":"csdn/简单介绍Kafka","date":"2022-10-13T15:38:26.000Z","updated":"2025-02-17T01:58:21.600Z","comments":true,"path":"api/articles/csdn/简单介绍Kafka.json","keywords":"Stephen web3","cover":[],"text":" Kafka 概念Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由 LinkedIn 公司开发，使用Scala 语言编写，目前是 Apach...","permalink":"/post/csdn/简单介绍Kafka","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"kafka kafka","slug":"kafka-kafka","count":1,"path":"api/tags/kafka-kafka.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"什么是AQS","uid":"7d9db4929e21c0d91333dbdc28b79909","slug":"csdn/什么是AQS","date":"2022-10-10T15:35:06.000Z","updated":"2025-02-17T01:58:21.600Z","comments":true,"path":"api/articles/csdn/什么是AQS.json","keywords":"Stephen web3","cover":[],"text":" AQS ( Abstract Queued Synchronizer ）是一个抽象的队列同步器，通过维护一个共享资源状态（ Volatile Int Stat...","permalink":"/post/csdn/什么是AQS","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"java","slug":"java","count":6,"path":"api/categories/java.json"}],"tags":[{"name":"面试 java 面试","slug":"面试-java-面试","count":1,"path":"api/tags/面试-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}