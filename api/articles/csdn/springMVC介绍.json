{"title":"springMVC介绍","uid":"98cffa2ec843f93b7a73d616ab307ba8","slug":"csdn/springMVC介绍","date":"2022-10-18T06:59:27.000Z","updated":"2025-02-17T01:58:21.599Z","comments":true,"path":"api/articles/csdn/springMVC介绍.json","keywords":"Stephen web3","cover":[],"content":"<link rel=\"stylesheet\" href=\"/owl.css\"><link rel=\"stylesheet\" class=\"aplayer-secondary-style-marker\" href=\"/assets/css/APlayer.min.css\"><script src=\"/assets/js/APlayer.min.js\" class=\"aplayer-secondary-script-marker\"></script><script class=\"meting-secondary-script-marker\" src=\"/assets/js/Meting.min.js\"></script><span id=\"more\"></span>\n\n<h2 id=\"一、springmvc初始化\"><a href=\"#一、springmvc初始化\" class=\"headerlink\" title=\"一、springmvc初始化\"></a>一、springmvc初始化</h2><p>        我们使用springMVC的时候，它的主要入口时dispatcherServlet类，它最终实现了Servlet接口。Servlet初始化执行init()方法，其中执行到springMVC子容器初始化的会调用DispatcherServlet的onRefresh()方法，而在onRefresh()方法中只做了一件事，就是调用initStrategies()方法来初始化springMVC的九大组件。</p>\n<p>        initStrategies直译过来就是初始化策略，而springMVC把九大组件设计成就打策略，其实就是为了去明确各个组件的职责，达到解耦的目的。按照springMVC九大组件的初始化顺序，他们分别是MultipartResolve多文件上传组件、LocaleResolver多语言支持组件、ThemeResolver主题模板处理组件、HandlerMappings URL映射组件、HandlerAdapters业务逻辑适配组件、HandlerExceptionResolvers异常处理组件、RequestToViewNameTranslator视图名称提取组件、ViewResolvers视图渲染组件、FlashMapManager内存管理组件。如图：</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/15c76f738e41ec44efbd383be7cd77e6.png\"></p>\n<p>下面详细分析一下每个组件的功能和职责。</p>\n<h3 id=\"1-MultipartResolver\"><a href=\"#1-MultipartResolver\" class=\"headerlink\" title=\"1.MultipartResolver\"></a>1.MultipartResolver</h3><p>        它主要是支持多文件上传，如代码所示。它主要的逻辑就是将enctype为”multipart&#x2F;form-data”的表单请求request封装成MultipartHttpServletRequest的对象，那程序员在开发的时候就只需要调用MultipartHttpServletRequest的getFile方法就可以获取客户端上传的文件列表了。</p>\n<h3 id=\"2-LocaleResolver\"><a href=\"#2-LocaleResolver\" class=\"headerlink\" title=\"2.LocaleResolver\"></a>2.LocaleResolver</h3><p>        它主要是用于支持国际化，多语言切换的组件，而LocaleResolver的主要作用就是从request中解析出local参数的值，如源码所示。resolveLocale方法它是从request中去解析出local而setLocal()方法是将指定的local值设置到request中，local对象大多数情况下都是用来做国际化处理的，一般会配合多语言字典properties来使用。例如中国的Local值为zh_CN。</p>\n<h3 id=\"3-ThemeResolver\"><a href=\"#3-ThemeResolver\" class=\"headerlink\" title=\"3.ThemeResolver\"></a>3.ThemeResolver</h3><p>        他主要是支持web页面的多主体风格切换，可以通过ThemeResolver来读取和解析页面的主题样式配置，它的实现原理和LocaleResolver类似，也是配置一套properties文件，然后根据不同的参数来切换读取。当然，使用ThemeResolver也可以实现国际化。如源码所示。它的主要方法和LocalResolver也类似。一个是从request中去提取主题名称的方法，一个是设置主题名称的方法。</p>\n<h3 id=\"4-HandlerMappings\"><a href=\"#4-HandlerMappings\" class=\"headerlink\" title=\"4.HandlerMappings\"></a>4.HandlerMappings</h3><p>        它主要是用来保存url和业务逻辑的对应关系，它本质上是一个Map，它的key是url，值就是对应Controller中配置了@RequestMapping注解的方法，但是这种关系呢在spring源码中被封装成一个叫做HandlerMapping的对象，然后每个HandlerMapping对象都被缓存到一个List中，如源码所示。</p>\n<h3 id=\"5-HandlerAdapters\"><a href=\"#5-HandlerAdapters\" class=\"headerlink\" title=\"5.HandlerAdapters\"></a>5.HandlerAdapters</h3><p>        它主要的功能是动态解析参数以及动态适配业务逻辑对应的Handler，如源码所示。在HandlerAdapter中它提供了一个叫做handle()的方法，它的第三个参数Object handler就是指业务逻辑处理器，也就是HandlerMapping。</p>\n<p>        handle()方法在DispatcherServlet中的doDispath()方法中被调用，而handler对象就是根据用户请求Url从handlerMapping的缓存List中去获取到的HandlerMapping对象，在HandlerAdapter的handle()方法中首先回去动态解析用户传过来的参数，并且会完成数据类型的转换，然后会反射调用HandlerMapping封装的Controller中的方法，最后会将调用方法的返回值封装为一个叫做ModelAndView的对象。</p>\n<h3 id=\"6-HandlerExceptionResolvers\"><a href=\"#6-HandlerExceptionResolvers\" class=\"headerlink\" title=\"6.HandlerExceptionResolvers\"></a>6.HandlerExceptionResolvers</h3><p>        它主要是用于拦截对不同异常的个性化处理，spring可以给不同的异常配置不同的ModelAndView,而HandlerExceptionResolver就是根据异常类型将处理封装为一个ModelAndView，从而将异常转化为更加友好的web页面展示。如源码所示。在HandlerExceptionResolver组件中只有一个方法就是将异常转化为ModelAndView，当HandlerExceptionResolver自己发生异常的时候或者在异常页面渲染过程中发生异常的时候HandlerExceptionResolver他不会进行处理，但是spring提供了一个全局的配置可以去设置500页面或者是404页面来处理这个问题。</p>\n<h3 id=\"7-RequestToViewNameTranslator\"><a href=\"#7-RequestToViewNameTranslator\" class=\"headerlink\" title=\"7.RequestToViewNameTranslator\"></a>7.RequestToViewNameTranslator</h3><p>        这个组件的主要功能是从request中去提取viewName,而这个viewName它可以设置在url参数上也可以设置在request的header上。如源码所示。这个其实挺有意思，就是将request的请求转化为视图名称。它只有一个getViewName()方法。</p>\n<h3 id=\"8-ViewResolvers\"><a href=\"#8-ViewResolvers\" class=\"headerlink\" title=\"8.ViewResolvers\"></a>8.ViewResolvers</h3><p>        就是根据视图名称找到视图对应的模板文件，然后进行解析。如源码所示。ViewResolver组件只有一个resolveViewName()方法，我们可以看到resolveViewName()方法中有两个参数，第一个参数是viewName,他是string类型它其实就是视图名称对应的模板文件的名称。第二个参数是local，前面我们讲过它代表的是本地语言环境，它可以用来做国际化。而resolveViewName()方法的返回值是一个View对象，View对象就是用来渲染的，也就是将程序返回的结果填入到具体的模板里面生产具体的视图文件，比如说jsp,ftl,html等待。</p>\n<h3 id=\"9-FlashMapManager\"><a href=\"#9-FlashMapManager\" class=\"headerlink\" title=\"9.FlashMapManager\"></a>9.FlashMapManager</h3><p>        它相当于一个参数缓存器可以用来去保证请求跳转过程中参数不会丢失，和struts2中的ValueStack值栈非常类似，主要是redirect重定向的时候参数传递会丢失，这时候FlashMapManager就能够大显身手，它可以实现Redirect重定向也能和Forward转发同样的效果。如源码所示。FlashMapManager主要有两个方法，一个是retrieveAndUpdate()方法它是用来恢复参数的，而且会将恢复的和超时的参数删除掉。第二个是saveOutputFlashMap()方法，它是用来保存参数的，FlashMapManager会默认将参数保存到session中。在日常开发中如果不想将参数暴露在url路径中，如果不想将参数暴露在url路径中那就一个在请求转发时在参数上添加@RedirectAttributes注解将参数缓存起来然后在下一个处理器中就可以获取到。</p>\n<p>        注意：ModelAndView和View并不属于MVC的九大组件之中，ModelAndView只是对ViewName和Model的封装然后作为返回值把信息反馈给用户，并且它并没有包含任何的执行逻辑。而view呢而是对模板的封装他是用作参数来传递。</p>\n<h2 id=\"二、springMVC请求执行流程\"><a href=\"#二、springMVC请求执行流程\" class=\"headerlink\" title=\"二、springMVC请求执行流程\"></a>二、springMVC请求执行流程</h2><p>        我们使用springMVC的时候，它的主要入口时dispatcherServlet类它最终实现了Servlet接口,那它就是个Servlet类。请求该方法会执行doService方法。请求来了，那接下来springMvc执行流程用图表示</p>\n<p><img src=\"https://i-blog.csdnimg.cn/blog_migrate/1c66731579d7c48b517825458e8fd3cd.png\"></p>\n<ol>\n<li>用户向服务端发送一次请求，这个请求会先到前端控制器DispatcherServlet(也叫中央控制器)。</li>\n<li>DispatcherServlet接收到请求后会调用HandlerMapping处理器映射器。由此得知，该请求该由哪个Controller来处理（并未调用Controller，只是得知）</li>\n<li>DispatcherServlet调用HandlerAdapter处理器适配器，告诉处理器适配器应该要去执行哪个Controller</li>\n<li>HandlerAdapter处理器适配器去执行Controller并得到ModelAndView(数据和视图)，并层层返回给DispatcherServlet</li>\n<li>DispatcherServlet将ModelAndView交给ViewReslover视图解析器解析，然后返回真正的视图。</li>\n<li>DispatcherServlet将模型数据填充到视图中</li>\n<li>DispatcherServlet将结果响应给用户</li>\n</ol>\n<p>Article link： <a href=\"https://tqgoblin.site/post/csdn/springMVC%E4%BB%8B%E7%BB%8D/\">https://tqgoblin.site/post/csdn/springMVC介绍/</a> <div align=left> Author：<a href=\"https://www.tqgoblin.site\"> Stephen </a> </div></p>\n","text":" 一、springmvc初始化 我们使用springMVC的时候，它的主要入口时dispatcherServlet类，它最终实现了Servlet接口。Servl...","permalink":"/post/csdn/springMVC介绍","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"spring","slug":"spring","count":1,"path":"api/categories/spring.json"}],"tags":[{"name":"面试 java spring","slug":"面试-java-spring","count":1,"path":"api/tags/面试-java-spring.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%80%E3%80%81springmvc%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">一、springmvc初始化</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-MultipartResolver\"><span class=\"toc-text\">1.MultipartResolver</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-LocaleResolver\"><span class=\"toc-text\">2.LocaleResolver</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#3-ThemeResolver\"><span class=\"toc-text\">3.ThemeResolver</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-HandlerMappings\"><span class=\"toc-text\">4.HandlerMappings</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-HandlerAdapters\"><span class=\"toc-text\">5.HandlerAdapters</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-HandlerExceptionResolvers\"><span class=\"toc-text\">6.HandlerExceptionResolvers</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#7-RequestToViewNameTranslator\"><span class=\"toc-text\">7.RequestToViewNameTranslator</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#8-ViewResolvers\"><span class=\"toc-text\">8.ViewResolvers</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#9-FlashMapManager\"><span class=\"toc-text\">9.FlashMapManager</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BA%8C%E3%80%81springMVC%E8%AF%B7%E6%B1%82%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">二、springMVC请求执行流程</span></a></li></ol>","author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"hidden":false,"prev_post":{"title":"Spring加载流程","uid":"92e817b0edbefb52af49230332579af2","slug":"csdn/Spring加载流程","date":"2022-10-18T08:43:29.000Z","updated":"2025-02-17T01:58:21.598Z","comments":true,"path":"api/articles/csdn/Spring加载流程.json","keywords":"Stephen web3","cover":[],"text":" 一、spring加载流程 tomcat在启动ServletContext容器的时候会发布ServletContextEvent事件，Spring就通过实现Se...","permalink":"/post/csdn/Spring加载流程","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"spring spring java 面试","slug":"spring-spring-java-面试","count":1,"path":"api/tags/spring-spring-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},"next_post":{"title":"java中的锁","uid":"1c003f281cf294408d7d24cc6188aa8e","slug":"csdn/java中的锁","date":"2022-10-14T15:40:19.000Z","updated":"2025-02-17T01:58:21.599Z","comments":true,"path":"api/articles/csdn/java中的锁.json","keywords":"Stephen web3","cover":[],"text":" Java提供了种类丰富的锁，每种锁因其特性的不同，在适当的场景下能够展现出非常高的效率。本文旨在对锁相关源码（本文中的源码来自JDK 8）、使用场景进行举例，...","permalink":"/post/csdn/java中的锁","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"java","slug":"java","count":6,"path":"api/categories/java.json"}],"tags":[{"name":"锁 java 面试","slug":"锁-java-面试","count":1,"path":"api/tags/锁-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}}