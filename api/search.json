[{"id":"e42cdbfca7d3b003c339c6ab5827f117","title":"GitLab CI/CD 实现自动构建部署项目","content":"一、环境准备首先需要有一台 GitLab 服务器，然后需要有个项目；这里示例项目以 Spring Boot 项目为例，然后最好有一台专门用来 Build 的机器，实际生产中如果 Build 任务不频繁可适当用一些业务机器进行 Build。\n\nGitLab IP :10.88.9.21  (version 12.6.0)\nRunner IP :10.88.9.37  (version 12.5.0)\n\n二、GitLab CI 简介GitLab CI 是 GitLab 默认集成的 CI 功能，GitLab CI 通过在项目内 .gitlab-ci.yaml 配置文件读取 CI 任务并进行相应处理；GitLab CI 通过其称为 GitLab Runner 的 Agent 端进行 build 操作；Runner 本身可以使用多种方式安装，比如使用 Docker 镜像启动等；Runner 在进行 build 操作时也可以选择多种 build 环境提供者；比如直接在 Runner 所在宿主机 build、通过新创建虚拟机(vmware、virtualbox)进行 build等；同时 Runner 支持 Docker 作为 build 提供者，即每次 build 新启动容器进行 build；GitLab CI 其大致架构如下\n三、GitLab搭建安准基础依赖\n安装基础依赖\n\nsudo yum install -y curl policycoreutils-python openssh-server\n启动ssh服务&amp;设置为开机启动\nsudo systemctl enable sshd\nsudo systemctl start sshd \n\n安装Postfix\n\nPostfix是一个邮件服务器，GitLab发送邮件需要用到\n# 安装postfix\nsudo yum install -y postfix\n\n# 启动postfix并设置为开机启动\nsudo systemctl enable postfix\nsudo systemctl start postfix\n\n开放ssh以及http服务（80端口)\n\n# 开放ssh、http服务\nsudo firewall-cmd --add-service&#x3D;ssh --permanent\nsudo firewall-cmd --add-service&#x3D;http --permanent\n# 重载防火墙规则\nsudo firewall-cmd --reload\n安装GitLab本次我们部署的是社区版:gitlab-ce，如果要部署商业版可以把关键字替换为：gitlab-ee\n\nYum安装GitLab\n\n# 新建 &#x2F;etc&#x2F;yum.repos.d&#x2F;gitlab-ce.repo，内容为\n[gitlab-ce]\nname&#x3D;Gitlab CE Repository\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-ce&#x2F;yum&#x2F;el$releasever&#x2F;\ngpgcheck&#x3D;0\nenabled&#x3D;1\n# 再执行\nsudo yum makecache\nsudo yum install gitlab-ce\n配置GitLabGitLab默认的配置文件路径是&#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb\n#修改配置文件\nsudo vim &#x2F;etc&#x2F;gitlab&#x2F;gitlab.rb\n#配置首页地址（大约在第15行）可以用IP代替域名，这里根据自己需求来即可\nexternal_url &#39;http:&#x2F;&#x2F;gitlab.ecloud.com&#39;\n启动并访问GitLab\n启动GitLab\n\n#重新配置并启动\nsudo gitlab-ctl reconfigure\n#完成后将会看到如下输出\nRunning handlers complete\nChef Client finished, 432&#x2F;613 resources updated in 03 minutes 43 seconds\ngitlab Reconfigured!\n\n访问 GitLab\n\n将设置的域名DNS解析到服务器IP，或者修改本地host将域名指向服务器IP。 访问：http://gitlab.ecloud.com \n\n设置密码\n\n这时候会提示为管理员账号设置密码。管理员账号默认username是root。 设置完成之后即可使用root账号登录，登陆后会进入欢迎界面。\n四、GitLab CI 配置增加 RunnerGitLab CI 在进行构建时会将任务下发给 Runner，让 Runner 去执行；所以先要添加一个 Runner\n# 新建 &#x2F;etc&#x2F;yum.repos.d&#x2F;gitlab-runner.repo，内容为\n[gitlab-runner]\nname&#x3D;gitlab-runner\nbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.tuna.tsinghua.edu.cn&#x2F;gitlab-runner&#x2F;yum&#x2F;el7\nrepo_gpgcheck&#x3D;0\ngpgcheck&#x3D;0\nenabled&#x3D;1\ngpgkey&#x3D;https:&#x2F;&#x2F;packages.gitlab.com&#x2F;gpg.key\n# 再执行\nsudo yum makecache\nsudo yum install gitlab-runner\ngitlab-runner 注册\n首先要先获取gitlab-ci的Token:项目主页 -&gt; Sttings -&gt; CI/CD -&gt; Runners Expand \n\n登录安装runner的服务器，使用命令注册gitlab-runner:\n\n\ngitlab-runner register\n\n\n输入gitlab的服务URL，这个使用的是http://gitlab.ecloud.com\n输入gitlab-ci的Toekn，获取方式参考上图\n关于集成服务中对于这个runner的描述\n给这个gitlab-runner输入一个标记，这个tag非常重要，在后续的使用过程中需要使用这个tag来指定gitlab-runner\n是否运行在没有tag的build上面。在配置gitlab-ci的时候，会有很多job，每个job可以通过tags属性来选择runner。这里为true表示如果job没有配置tags，也执行\n是否锁定runner到当前项目\n选择执行器，gitlab-runner实现了很多执行器，可用在不同场景中运行构建，详情可见GitLab Runner Executors，这里选用Shell模式\n刷新页面就可以看到新增的一个Runner:\n\n\n 9.这个GitLabRunner就安装好了，下一步就是把项目集成到gitlab-ci中，开始持续集成了。\ngitlab-runner 使用\n创建 CI 配置文件一切准备就绪以后，就可以编写 CI 脚本了；GitLab 依靠读取项目根目录下的 .gitlab-ci.yml 文件来执行相应的 CI 操作；以下为测试项目的 .gitlab-ci.yml 配置\n\n# These are the default stages. You don&#39;t need to explicitly define them. But you could define any stages you need.\nstages:\n- build\n- deploy\n- catLog\n- kill\n\nvariables:\nMAVEN_CLI_OPTS: &quot;-s .m2&#x2F;settings.xml --batch-mode&quot;\nMAVEN_OPTS: &quot;-Dmaven.repo.local&#x3D;&#x2F;export&#x2F;servers&#x2F;repository_boot&quot;\nSHELL_NAME: &quot;ry.sh&quot;\ncache:\npaths:\n# - .m2&#x2F;repository\n- target&#x2F;\n\n# This is the name of the job. You can choose it freely.\nmaven_build:\n# A job is always executed within a stage. If no stage is set, it defaults to &#39;test&#39;\nstage: build\n# Since we require Maven for this job, we can restrict the job to runners with a certain tag. Of course, we need to configure a runner with the tag maven with a maven installation\ntags:\n- dev\n# 使用当前作业的名称和当前分支或标签（仅包括二进制文件目录）创建档案\nartifacts:\nname: &quot;$CI_JOB_NAME-$CI_COMMIT_REF_NAME&quot;\nexpire_in: 4 week\npaths:\n- target&#x2F;*.jar\n# Here you can execute arbitrate terminal commands.\n# If any of the commands returns a non zero exit code the job fails\nscript:\n- echo &quot;Building project with maven&quot;\n- mvn $MAVEN_CLI_OPTS clean\n- mvn $MAVEN_CLI_OPTS install\ndeploy_jdk8:\nstage: deploy\ntags:\n- dev\nscript:\n- echo &quot;Deploy....&quot;\n- sh $SHELL_NAME restart\nwhen: on_success\ninterruptible: true\n\ncat_boot_log:\nstage: catLog\ntags:\n- dev\nscript:\n- echo &quot;cat  log....&quot;\n- sh $SHELL_NAME cat\nwhen: on_success\n\nkill_progress:\nstage: kill\ntags:\n- dev\nscript:\n- echo &quot;kill progress&quot;\n- sh $SHELL_NAME stop\nwhen: manual\n\n\n\n关于 .gitlab-ci.yml 具体配置更完整的请参考 官方文档\n\n\n\n\n\n\n\n\n\n文中测试项目:  点击下载\nArticle link： https://tqgoblin.site/post/gitlab-cicd/  Author： Stephen  \n","slug":"gitlab-cicd","date":"2019-12-22T02:48:00.000Z","categories_index":"运维","tags_index":"GitLab","author_index":"Stephen"},{"id":"77d3e41277be521fb04715814e170fee","title":"Activiti 学习笔记（二）","content":"一、Activiti 入门体验流程定义Palette（画板）在 eclipse 或 idea 中安装 activiti-designer 插件即可使用，画板中包括以下结点：\n\nConnection—连接\nEvent—事件\nTask—任务\nGateway—网关\nContainer—容器\nBoundary event—边界事件\nIntermediate event- -中间事件\n流程图设计完毕保存生成.bpmn 文件。\n\n新建流程 （IDEA）\n\n起完名字 holiday 后（默认扩展名为 bpmn），就可以看到进入了流程设计页面，如图所示：\n\n\n绘制流程左侧区域是绘图区，右侧区域是 palette 画板区域 ，鼠标先点击画板的元素即可在左侧绘图。\n指定流程定义Key流程定义 key 即流程定义的标识，在 idea 中通过 properties 视图查看流程的 key建议：相同的业务流程，流程定义的 key 名字定义一样，比如，如果需要创建新的业务流程，请假流程则使用新的 key。\n\n\n指定任务负责人在 properties 视图指定每个任务结点的负责人，比如下边是填写请假单的负责人为 zhangsan\n\n\n\n\n\n\n\n\n\n\n\n生成png流程图 参考 Idea创建bpmn文件没有png图片解决办法\n部署流程定义部署流程定义就是要将上边绘制的图形即流程定义（.bpmn）部署在工作流程引擎 activiti 中，方法如下：\n&#x2F;**\n * 流程定义的部署\n * activiti表有哪些？\n *  act_re_deployment  部署信息\n    act_re_procdef     流程定义的一些信息\n    act_ge_bytearray   流程定义的bpmn文件及png文件\n *&#x2F;\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;1.创建ProcessEngine对象\n    ProcessEngine processEngine &#x3D; ProcessEngines.getDefaultProcessEngine();\n\n    &#x2F;&#x2F;2.得到RepositoryService实例\n    RepositoryService repositoryService &#x3D; processEngine.getRepositoryService();\n\n    &#x2F;&#x2F;3.进行部署\n    Deployment deployment &#x3D; repositoryService.createDeployment()\n            .addClasspathResource(&quot;diagram&#x2F;holiday.bpmn&quot;)  &#x2F;&#x2F;添加bpmn资源\n            .addClasspathResource(&quot;diagram&#x2F;holiday.png&quot;)\n            .name(&quot;请假申请单流程&quot;)\n            .deploy();\n\n    &#x2F;&#x2F;4.输出部署的一些信息\n    System.out.println(deployment.getName());\n    System.out.println(deployment.getId());\n&#125;\n\n\n\n启动一个流程实例流程定义部署在 activiti 后就可以通过工作流管理业务流程了，也就是说上边部署的请假申请流程可以使用了。针对该流程，启动一个流程表示发起一个新的请假申请单，这就相当于 java 类与 java 对象的关系，类定义好后需要 new 创建一个对象使用，当然可以 new 多个对象。对于请假申请流程，张三发起一个请假申请单需要启动一个流程实例，请假申请单发起一个请假单也需要启动一个流程实例。代码如下：\n    &#x2F;**\n    * 启动流程实例:\n    *     前提是先已经完成流程定义的部署工作\n    *\n    *     背后影响的表：\n    *       act_hi_actinst     已完成的活动信息\n         act_hi_identitylink   参与者信息\n         act_hi_procinst   流程实例\n         act_hi_taskinst   任务实例\n         act_ru_execution   执行表\n         act_ru_identitylink   参与者信息\n         act_ru_task  任务\n    *&#x2F;\npublic class ActivitiStartInstance &#123;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;1.得到ProcessEngine对象\n        ProcessEngine processEngine &#x3D; ProcessEngines.getDefaultProcessEngine();\n\n        &#x2F;&#x2F;2.得到RunService对象\n        RuntimeService runtimeService &#x3D; processEngine.getRuntimeService();\n\n        &#x2F;&#x2F;3.创建流程实例  流程定义的key需要知道 holiday\n        ProcessInstance processInstance &#x3D; runtimeService.startProcessInstanceByKey(&quot;holiday&quot;);\n\n\n        &#x2F;&#x2F;4.输出实例的相关信息\n        System.out.println(&quot;流程部署ID&quot;+processInstance.getDeploymentId());&#x2F;&#x2F;null\n        System.out.println(&quot;流程定义ID&quot;+processInstance.getProcessDefinitionId());&#x2F;&#x2F;holiday:1:4\n        System.out.println(&quot;流程实例ID&quot;+processInstance.getId());&#x2F;&#x2F;2501\n        System.out.println(&quot;活动ID&quot;+processInstance.getActivityId());&#x2F;&#x2F;null\n\n    &#125;\n\n\n任务查询流程启动后，各各任务的负责人就可以查询自己当前需要处理的任务，查询出来的任务都是该用户的待办任务。\n &#x2F;&#x2F;zhangsan完成自己任务列表的查询\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;1.得到ProcessEngine对象\n    ProcessEngine processEngine &#x3D; ProcessEngines.getDefaultProcessEngine();\n\n    &#x2F;&#x2F;2.得到TaskService对象\n    TaskService taskService &#x3D; processEngine.getTaskService();\n\n    &#x2F;&#x2F;3.根据流程定义的key,负责人assignee来实现当前用户的任务列表查询\n    Task task &#x3D; taskService.createTaskQuery()\n            .processDefinitionKey(&quot;holiday&quot;)\n            .taskAssignee(&quot;zhangsan&quot;)\n            .singleResult();\n\n    &#x2F;&#x2F;4.任务列表的展示\n    System.out.println(&quot;流程实例ID:&quot;+task.getProcessInstanceId()); &#x2F;&#x2F;2501\n    System.out.println(&quot;任务ID:&quot;+task.getId());  &#x2F;&#x2F;2505\n    System.out.println(&quot;任务负责人:&quot;+task.getAssignee()); &#x2F;&#x2F;zhangsan\n    System.out.println(&quot;任务名称:&quot;+task.getName()); &#x2F;&#x2F;填写请假申请单\n\n&#125;\n\n\n任务处理任务负责人查询待办任务，选择任务进行处理，完成任务。\n&#x2F;**\n * zhangsan完成自己的任务\n * 处理当前用户的任务\n * 背后操作的表：\n *   act_hi_actinst\n     act_hi_identitylink\n     act_hi_taskinst\n     act_ru_identitylink\n     act_ru_task\n *&#x2F;\npublic static void main(String[] args) &#123;\n    &#x2F;&#x2F;1.得到ProcessEngine对象\n    ProcessEngine processEngine &#x3D; ProcessEngines.getDefaultProcessEngine();\n\n    &#x2F;&#x2F;2.得到TaskService对象\n    TaskService taskService &#x3D; processEngine.getTaskService();\n\n    &#x2F;&#x2F;3.处理任务,结合当前用户任务列表的查询操作的话,任务ID:2505\n    taskService.complete(&quot;2505&quot;);\n    \n&#125;\n\n流程定义删除    &#x2F;**\n     * 删除已经部署的流程定义\n     *\n     * 背后影响的表:\n     * act_ge_bytearray\n       act_re_deployment\n       act_re_procdef\n     *&#x2F;\npublic class DeleteProcessDefinition &#123;\n\n    &#x2F;**\n     * 注意事项：\n     *     1.当我们正在执行的这一套流程没有完全审批结束的时候，此时如果要删除流程定义信息就会失败\n     *     2.如果公司层面要强制删除,可以使用repositoryService.deleteDeployment(&quot;1&quot;,true);\n     *     &#x2F;&#x2F;参数true代表级联删除，此时就会先删除没有完成的流程结点，最后就可以删除流程定义信息  false的值代表不级联\n     *\n     * @param args\n     *&#x2F;\n    public static void main(String[] args) &#123;\n        &#x2F;&#x2F;1.得到ProcessEngine对象\n        ProcessEngine processEngine &#x3D; ProcessEngines.getDefaultProcessEngine();\n\n        &#x2F;&#x2F;2.创建RepositoryService对象\n        RepositoryService repositoryService &#x3D; processEngine.getRepositoryService();\n\n        &#x2F;&#x2F;3.执行删除流程定义  参数代表流程部署的id\n        repositoryService.deleteDeployment(&quot;1&quot;);\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n\n说明：\n\n使用 repositoryService 删除流程定义\n如果该流程定义下没有正在运行的流程，则可以用普通删除。\n如果该流程定义下存在已经运行的流程，使用普通删除报错，可用级联删除方法将流程及相关记录全部删除。项目开发中使用级联删除的情况比较多，删除操作一般只开放给超级管理员使用。\n\n流程定义资源查询通过流程定义对象获取流程定义资源，获取 bpmn 和 png。\n&#x2F;**\n * 需求：\n * 1.从Activiti的act_ge_bytearray表中读取两个资源文件\n * 2.将两个资源文件保存到路径：   &#x2F;Users&#x2F;mac&#x2F;Desktop&#x2F;diagram&#x2F;\n *\n * 技术方案：\n *     1.第一种方式使用actviti的api来实现\n *     2.第二种方式：其实就是原理层面，可以使用jdbc的对blob类型，clob类型数据的读取，并保存\n *        IO流转换，最好commons-io.jar包可以轻松解决IO操作\n *\n * 真实应用场景：用户想查看这个请假流程具体有哪些步骤要走？\n *\n *\n *&#x2F;\npublic class QueryBpmnFile &#123;\n\n    public static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F;1.得到ProcessEngine对象\n        ProcessEngine processEngine &#x3D; ProcessEngines.getDefaultProcessEngine();\n\n        &#x2F;&#x2F;2.得到RepositoryService对象\n        RepositoryService repositoryService &#x3D; processEngine.getRepositoryService();\n\n        &#x2F;&#x2F;3.得到查询器:ProcessDefinitionQuery对象\n        ProcessDefinitionQuery processDefinitionQuery &#x3D; repositoryService.createProcessDefinitionQuery();\n\n        &#x2F;&#x2F;4.设置查询条件\n        processDefinitionQuery.processDefinitionKey(&quot;holiday&quot;);&#x2F;&#x2F;参数是流程定义的key\n\n        &#x2F;&#x2F;5.执行查询操作,查询出想要的流程定义\n        ProcessDefinition processDefinition &#x3D; processDefinitionQuery.singleResult();\n\n        &#x2F;&#x2F;6.通过流程定义信息，得到部署ID\n        String deploymentId &#x3D; processDefinition.getDeploymentId();\n\n        &#x2F;&#x2F;7.通过repositoryService的方法,实现读取图片信息及bpmn文件信息(输入流)\n        &#x2F;&#x2F;getResourceAsStream()方法的参数说明：第一个参数部署id,第二个参数代表资源名称\n        &#x2F;&#x2F;processDefinition.getDiagramResourceName() 代表获取png图片资源的名称\n        &#x2F;&#x2F;processDefinition.getResourceName()代表获取bpmn文件的名称\n        InputStream pngIs &#x3D; repositoryService\n                .getResourceAsStream(deploymentId,processDefinition.getDiagramResourceName());\n        InputStream bpmnIs &#x3D; repositoryService\n                .getResourceAsStream(deploymentId,processDefinition.getResourceName());\n\n        &#x2F;&#x2F;8.构建出OutputStream流\n        OutputStream pngOs &#x3D;\n                new FileOutputStream(new File(&quot;&#x2F;Users&#x2F;mac&#x2F;Desktop&#x2F;&quot;+processDefinition.getDiagramResourceName()));\n\n        OutputStream bpmnOs &#x3D;\n                new FileOutputStream(new File(&quot;&#x2F;Users&#x2F;mac&#x2F;Desktop&#x2F;&quot;+processDefinition.getResourceName()));\n\n        &#x2F;&#x2F;9.输入流，输出流的转换  commons-io-xx.jar中的方法\n        IOUtils.copy(pngIs,pngOs);\n        IOUtils.copy(bpmnIs,bpmnOs);\n        &#x2F;&#x2F;10.关闭流\n        pngOs.close();\n        bpmnOs.close();\n        pngIs.close();\n        bpmnIs.close();\n\n    &#125;\n&#125;\n\n流程历史信息的查看即使流程定义已经删除了，流程执行的历史信息通过前面的分析，依然保存在 activiti 的 act_hi_*相关的表中。所以我们还是可以查询流程执行的历史信息，可以通过 HistoryService 来查看相关的历史记录。\npublic static void main(String[] args) throws IOException &#123;\n        &#x2F;&#x2F;1.得到ProcessEngine对象\n        ProcessEngine processEngine &#x3D; ProcessEngines.getDefaultProcessEngine();\n\n        &#x2F;&#x2F;2.得到HistoryService\n        HistoryService historyService &#x3D; processEngine.getHistoryService();\n\n        &#x2F;&#x2F;3.得到HistoricActivitiInstanceQuery对象\n        HistoricActivityInstanceQuery historicActivityInstanceQuery &#x3D; historyService.createHistoricActivityInstanceQuery();\n\n        historicActivityInstanceQuery.processInstanceId(&quot;10001&quot;);&#x2F;&#x2F;设置流程实例的id\n\n        &#x2F;&#x2F;4.执行查询\n        List&lt;HistoricActivityInstance&gt; list &#x3D; historicActivityInstanceQuery\n                .orderByHistoricActivityInstanceStartTime().asc().list();&#x2F;&#x2F;排序StartTime\n\n        &#x2F;&#x2F;5.遍历查询结果\n        for (HistoricActivityInstance instance :list)&#123;\n            System.out.println(instance.getActivityId());\n            System.out.println(instance.getActivityName());\n            System.out.println(instance.getProcessDefinitionId());\n            System.out.println(instance.getProcessInstanceId());\n            System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;);\n        &#125;\n    &#125;\n\n\nArticle link： https://tqgoblin.site/post/activiti学习笔记(二)/  Author： Stephen  \n","slug":"activiti学习笔记(二)","date":"2019-11-25T14:48:00.000Z","categories_index":"Activiti","tags_index":"Activiti","author_index":"Stephen"},{"id":"41fd5f0c4276a28984db38b1e679ed38","title":"Activiti 学习笔记（一）","content":"一、 Activiti流程引擎简介\n此项目于2010年Tom Bayen（jBPM创始人）离开jBoss后加入Alfresco公司之后的又一力作；第一版在2010年5月发布，当时仅支持最简单的流程处理，后来版本发布频率固定为每两个月一版。 值得一提的是参与项目开发的除了Tom Bayen和十几位核心开发人员之外还有其他公司的成员的参与，例如：SpringSource、MuleSoft、Salves、Signavio、FuseSource、NextLevel等公司。  \nActiviti是一个针对企业用户、开发人员、系统管理员轻量级工作流业务管理平台。其核心是使用Java开发的快速、稳定BPMN 2.0流程引擎。Activiti 是在 Apache V2 许可下发布的。Activiti可以运行在任何类型的Java程序中，例如服务器、集群、云服务。它可以完美地与Spring集成。计基于简约思想的设计使Activiti非常的轻量级。 它有着活跃的社区，而且越来越多的企业都选择Activiti作为自己的流程引擎或者嵌入到自己的系统平台中（例如ESB）。\n\n二、 Activiti 数据库支持Activiti的后台是有数据库的支持，所有的表都以ACT_开头。 第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。 \n\nACT_RE_*: ‘RE’表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。 \nACT_RU_*: ‘RU’表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。 \nACT_ID_*: ‘ID’表示identity。 这些表包含身份信息，比如用户，组等等。 \nACT_HI_*: ‘HI’表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。 \nACT_GE_*: 通用数据， 用于不同场景下，如存放资源文件\n\n三、 Activiti 如何使用1. 部署ActivitiActiviti 是一个工作流引擎（其实就是一堆jar包 API），业务系统使用 activiti 来对系统的业务流程进行自动化管理，为了方便业务系统访问(操作)activiti 的接口或功能，通常将 activiti 环境与业务系统的环境集成在一起。\n2. 流程定义使用 activiti 流程建模工具(activity-designer)定义业务流程(.bpmn 文件) 。.bpmn 文件就是业务流程定义文件，通过 xml 定义业务流程。如果使用其它公司开发的工作作引擎一般都提供了可视化的建模工具(Process Designer)用于生成流程定义文件，建模工具操作直观，一般都支持图形化拖拽方式、多窗口的用户界面、丰富的过程图形元素、过程元素拷贝、粘贴、删除等功能。\n\n\n3. 流程定义部署向 activiti 部署业务流程定义（.bpmn 文件）。使用 activiti 提供的 api 向 activiti 中部署.bpmn 文件（一般情况还需要一块儿部署业务流程的图片.png）\n4. 启动一个流程实例(ProcessInstance)启动一个流程实例表示开始一次业务流程的运行，比如员工请假流程部署完成，如果张三要请假就可以启动一个流程实例，如果李四要请假也启动一个流程实例，两个流程的执行互相不影响，就好比定义一个 java 类，实例化两个对象一样，部署的流程就好比 java 类，启动一个流程实例就好比 new 一个 java 对象。\n5. 用户查询代办任务(Task)因为现在系统的业务流程已经交给 activiti 管理，通过 activiti 就可以查询当前流程执行到哪了，当前用户需要办理什么任务了，这些 activiti帮我们管理了，而不像上边需要我们在 sql语句中的where条件中指定当前查询的状态值是多少。\n6. 用户办理任务用户查询待办任务后，就可以办理某个任务，如果这个任务办理完成还需要其它用户办理，比如采购单创建后由部门经理审核，这个过程也是由 activiti 帮我们完成了，不需要我们在代码中硬编码指定下一个任务办理人了。\n7. 流程结束当任务办理完成没有下一个任务&#x2F;结点了，这个流程实例就完成了。\n四、 Activiti 服务架构图\n\n在新版本中， IdentityService，FormService 两个 Serivce 都已经删除了。\n1. activiti.cfg.xmlactiviti 的引擎配置文件，包括：ProcessEngineConfiguration 的定义、数据源定义、事务管理器等，此文件其实就是一个 spring 配置文件，下面是一个基本的配置只配置了 ProcessEngineConfiguration和数据源：\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\n       xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n\t\t\t\t\t\thttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;contex http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd\n\t\t\t\t\t\thttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;&gt;\n\n    &lt;!--数据源配置dbcp--&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;\n        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;\n        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;activiti&quot; &#x2F;&gt;\n        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;\n        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;!--activiti单独运行的ProcessEngine配置对象(processEngineConfiguration),使用单独启动方式\n        默认情况下：bean的id&#x3D;processEngineConfiguration\n    --&gt;\n    &lt;bean id&#x3D;&quot;processEngineConfiguration&quot; class&#x3D;&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;&gt;\n    &lt;!--代表数据源--&gt;\n    &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&gt;&lt;&#x2F;property&gt;\n    &lt;!--代表是否生成表结构--&gt;\n    &lt;property name&#x3D;&quot;databaseSchemaUpdate&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n&lt;&#x2F;beans&gt;\n\n2. ProcessEngineConfiguration流程引擎的配置类，通过 ProcessEngineConfiguration 可以创建工作流引擎 ProceccEngine，常用的两种方法如下：\nStandaloneProcessEngineConfiguration通过org.activiti.engine.impl.cfg.StandaloneProcessEngineConfigurationActiviti 可以单独运行，使用它创建的 ProcessEngine，Activiti 会自己处理事务。\n配置文件方式：通常在 activiti.cfg.xml 配置文件中定义一个 id 为 processEngineConfiguration 的 bean，这里会使用 spring 的依赖注入来构建引擎。\n&lt;bean id&#x3D;&quot;processEngineConfiguration&quot;\nclass&#x3D;&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfig\nuration&quot;&gt;\n&lt;!-- 数据源 --&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;\n&lt;!-- 数据库策略 --&gt; &lt;property name&#x3D;&quot;databaseSchemaUpdate&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\nSpringProcessEngineConfiguration通过 org.activiti.spring.SpringProcessEngineConfiguration 与 Spring 整合。创建 spring 与 activiti 的整合配置文件：activity-spring.cfg.xml（名称不固定）\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\nxmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\nxmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;\nxmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;\nxmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;\nxmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;\nxsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans \nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-3.1.xsd \nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc \nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc-3.1.xsd \nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context \nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context-3.1.xsd \nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop \nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-3.1.xsd \nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx \nhttp:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx-3.1.xsd &quot;&gt;\n&lt;!-- 工作流引擎配置bean --&gt; &lt;bean id&#x3D;&quot;processEngineConfiguration&quot;\nclass&#x3D;&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;&gt;\n&lt;!-- 数据源 --&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;\n&lt;!-- 使用spring事务管理器 --&gt; &lt;property name&#x3D;&quot;transactionManager&quot; ref&#x3D;&quot;transactionManager&quot; &#x2F;&gt;\n&lt;!-- 数据库策略 --&gt; &lt;property name&#x3D;&quot;databaseSchemaUpdate&quot; value&#x3D;&quot;drop-create&quot; &#x2F;&gt;\n&lt;!-- activiti的定时任务关闭 --&gt; &lt;property name&#x3D;&quot;jobExecutorActivate&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;!-- 流程引擎 --&gt; &lt;bean id&#x3D;&quot;processEngine&quot;\nclass&#x3D;&quot;org.activiti.spring.ProcessEngineFactoryBean&quot;&gt;\n\n&lt;property name&#x3D;&quot;processEngineConfiguration&quot;\nref&#x3D;&quot;processEngineConfiguration&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;!-- 资源服务service --&gt; &lt;bean id&#x3D;&quot;repositoryService&quot; factory-bean&#x3D;&quot;processEngine&quot;\nfactory-method&#x3D;&quot;getRepositoryService&quot; &#x2F;&gt;\n&lt;!-- 流程运行service --&gt; &lt;bean id&#x3D;&quot;runtimeService&quot; factory-bean&#x3D;&quot;processEngine&quot;\nfactory-method&#x3D;&quot;getRuntimeService&quot; &#x2F;&gt;\n&lt;!-- 任务管理service --&gt; &lt;bean id&#x3D;&quot;taskService&quot; factory-bean&#x3D;&quot;processEngine&quot;\nfactory-method&#x3D;&quot;getTaskService&quot; &#x2F;&gt;\n&lt;!-- 历史管理service --&gt; &lt;bean id&#x3D;&quot;historyService&quot; factory-bean&#x3D;&quot;processEngine&quot;\nfactory-method&#x3D;&quot;getHistoryService&quot; &#x2F;&gt;\n&lt;!-- 用户管理service --&gt; &lt;bean id&#x3D;&quot;identityService&quot; factory-bean&#x3D;&quot;processEngine&quot;\nfactory-method&#x3D;&quot;getIdentityService&quot; &#x2F;&gt;\n&lt;!-- 引擎管理service --&gt; &lt;bean id&#x3D;&quot;managementService&quot; factory-bean&#x3D;&quot;processEngine&quot;\nfactory-method&#x3D;&quot;getManagementService&quot; &#x2F;&gt;\n&lt;!-- 数据源 --&gt; &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;\n&lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;activiti&quot; &#x2F;&gt;\n&lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;\n&lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;mysql&quot; &#x2F;&gt;\n&lt;property name&#x3D;&quot;maxActive&quot; value&#x3D;&quot;3&quot; &#x2F;&gt;\n&lt;property name&#x3D;&quot;maxIdle&quot; value&#x3D;&quot;1&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;!-- 事务管理器 --&gt; &lt;bean id&#x3D;&quot;transactionManager&quot;\nclass&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;!-- 通知 --&gt; &lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt; &lt;tx:attributes&gt;\n&lt;!-- 传播行为 --&gt; &lt;tx:method name&#x3D;&quot;save*&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt;\n\n&lt;tx:method name&#x3D;&quot;insert*&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt;\n&lt;tx:method name&#x3D;&quot;delete*&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt;\n&lt;tx:method name&#x3D;&quot;update*&quot; propagation&#x3D;&quot;REQUIRED&quot; &#x2F;&gt;\n&lt;tx:method name&#x3D;&quot;find*&quot; propagation&#x3D;&quot;SUPPORTS&quot; read-only&#x3D;&quot;true&quot; &#x2F;&gt;\n&lt;tx:method name&#x3D;&quot;get*&quot; propagation&#x3D;&quot;SUPPORTS&quot; read-only&#x3D;&quot;true&quot; &#x2F;&gt;\n&lt;&#x2F;tx:attributes&gt;\n&lt;&#x2F;tx:advice&gt;\n&lt;!-- 切面，根据具体项目修改切点配置 --&gt; &lt;aop:config proxy-target-class&#x3D;&quot;true&quot;&gt; &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot;\npointcut&#x3D;&quot;execution(* com.itheima.ihrm.service.impl.*.*(..))&quot; &#x2F;&gt;\n&lt;&#x2F;aop:config&gt;\n&lt;&#x2F;beans&gt;\n\n\n3. ProcessEngine工作流引擎，相当于一个门面接口，通过 ProcessEngineConfiguration 创建 processEngine，通过ProcessEngine 创建各个 service 接口。\n一般创建方式&#x2F;&#x2F;1.创建ProcessEngineConfiguration对象  第一个参数:配置文件名称  第二个参数是processEngineConfiguration的bean的id\n\nProcessEngineConfiguration configuration &#x3D; ProcessEngineConfiguration\n        .createProcessEngineConfigurationFromResource(&quot;activiti.cfg.xml&quot;,&quot;processEngineConfiguration&quot;);\n                \n&#x2F;&#x2F;2.创建ProcesEngine对象\n                \nProcessEngine processEngine &#x3D; configuration.buildProcessEngine();\n\n&#x2F;&#x2F;3.输出processEngine对象\n\nSystem.out.println(processEngine)\n简单创建方式将 activiti.cfg.xml 文件名及路径固定，且 activiti.cfg.xml 文件中有 processEngineConfiguration 的配置，可以使用如下代码创建 processEngine\n&#x2F;&#x2F;条件：1.activiti配置文件名称：activiti.cfg.xml   2.bean的id&#x3D;&quot;processEngineConfiguration&quot;\n       ProcessEngine processEngine &#x3D; ProcessEngines.getDefaultProcessEngine();\n4. ServiceService 创建方式 通过 ProcessEngine 创建 Service，Service 是工作流引擎提供用于进行工作流部署、执行、管理的服务接口。方式如下：\nRuntimeService runtimeService &#x3D; processEngine.getRuntimeService();\nRepositoryService repositoryService &#x3D; processEngine.getRepositoryService();\nTaskService taskService &#x3D; processEngine.getTaskService();\n......\nService 总览\n\n\n服务\n作用\n\n\n\nRepositoryService\nactiviti 的资源管理类\n\n\nRuntimeService\nactiviti 的流程运行管理类\n\n\nTaskService\nactiviti 的任务管理类\n\n\nHistoryService\nactiviti 的历史管理类\n\n\nManagerService\nactiviti 的引擎管理类\n\n\nRepositoryService\n是 activiti 的资源管理类，提供了管理和控制流程发布包和流程定义的操作。使用工作流建模工具设计的业务流程图需要使用此 service 将流程定义文件的内容部署到数据库。 除了部署流程定义以外还可以：\n查询引擎中的发布包和流程定义。\n暂停或激活发布包，对应全部和特定流程定义。 暂停意味着它们不能再执行任何操作了，激活是对应的反向操作。\n获得多种资源，像是包含在发布包里的文件， 或引擎自动生成的流程图。\n获得流程定义的 pojo 版本， 可以用来通过 java 解析流程，而不必通过 xml。\n\nRuntimeService它是 activiti 的流程运行管理类。可以从这个服务类中获取很多关于流程执行相关的信息\nTaskService是 activiti 的任务管理类。可以从这个类中获取任务的信息。\nHistoryService是 activiti 的历史管理类，可以查询历史信息，执行流程时，引擎会保存很多数据（根据配置），比如流程实例启动时间，任务的参与者， 完成任务的时间，每个流程实例的执行路径，等等。 这个服务主要通过查询功能来获得这些数据。\nManagementService是 activiti 的引擎管理类，提供了对 Activiti 流程引擎的管理和维护功能，这些功能不在工作流驱动的应用程序中使用，主要用于 Activiti 系统的日常维护。\nArticle link： https://tqgoblin.site/post/activiti学习笔记(一)/  Author： Stephen  \n","slug":"activiti学习笔记(一)","date":"2019-11-22T15:58:00.000Z","categories_index":"Activiti","tags_index":"Activiti","author_index":"Stephen"},{"id":"e8faf659d92c2b0deb12ac2619d15d18","title":"THUCTC 文本分类中jar冲突","content":"我将完整的THUCTC的Demo项目作为moudle引入到自己的工程中，Demo在其自己的moudle中可以正常运行，但我将Demo的代码整合到自己的工程中时，出现了如下错误\n\n\n发现自己的工程中引入了高版本的snowball包，但是遗憾的是我并不能将它降低版本。高版本中的Amog类的构造方法发生了改变，造成了这个错误。\n\n\n解决方案: \n  修改THUCTC工程中snowball包路径，重新打成jar包，再引入自己工程即可\n\n\n\n\nArticle link： https://tqgoblin.site/post/thuctc分类/  Author： Stephen  \n","slug":"thuctc分类","date":"2019-11-02T07:08:30.000Z","categories_index":"踩坑之路","tags_index":"大数据","author_index":"Stephen"},{"id":"e384082c21cec712db7f9620d92150dc","title":"科学上网","content":"一、利用Chrome的谷歌助手实现科学上网\n进入Chrome的扩展程序界面\n\n  \n\n\n打开开发者模式\n\n    \n\n\n点击 加载已解压的扩展程序\n\n      \n\n\n加载谷歌助手\n\n    \n\n\n\n等待谷歌助手加载完成就能访问了\n\n    \n  \n\n\n  \n  \n  \n\n\n\n\n\n\n\n\n\n软件包:  点击下载  (Mac  Win 通用)\n二、Lantern代理\n谷歌助手虽然能让我们在谷歌商场下载插件，但如果是访问Youtube等网站就不能满足需求了\n\n\n使用 Lantern代理 每月有500MB 免费流量  能满足轻量用户需求 \n\n\n  \n\n\n\n\n\n\n\n\n\n\n\n\n官网地址 https://getlantern.org/zh_CN/index.html\n三、ShadowsocksX\n该软件能实现全局代理，可选服务器多 ，但是收费 🙂\n\n  \n\n  \n\n\n\n\n\n\n\n\n\n\n\n软件包:  点击下载  (mac 版)\nArticle link： https://tqgoblin.site/post/科学上网/  Author： Stephen  \n","slug":"科学上网","date":"2019-08-08T05:48:00.000Z","categories_index":"科学上网","tags_index":"科学上网","author_index":"Stephen"},{"id":"bc148c47b074649417f33e22cc961a4a","title":"private","content":"\n  76a95db47c288b0644d34172affb81a3d71f7e0c07e70fbecabc5e9c53ed2236e2ed4fa095521d3cf15b0ce92e5737fe6886aafe39b200e8592d42be37022cf15d4abb62a2d0c2a6ea42e53ef22366b3b428f5627e7a0892ad4bb3f32e5fcc0a6c03e7492e1e3f2ab02f9067e5257f3f28eb1905d0246de263f83f788da66651b7fb4527319e5d8d1cc6c2e18798f2da99de0417809225e031d051cd739ad8325a3ccdc582b9db575ae8476bd062b5324a28092fc844571bc766eb203d9a83c17d4407fc55a9da64c00843b30d4db48bccea27cf83acfe2f5a62b00272fa1a2c556b844af34f215b12cd1967221b3c10a8ab52aa1ce4af28b2820d105536a3810e68bceee21c9f57f98153f534ff0ee91ca19f9928caa0118e017530b2359086af0d5614e7da4c116e51db8f2e8db6bd7c624b464833d648e85c19a906c39dd31d22c7be81943a1a76ebd2ccad52a162c3120fba8f25389a9c351af7bd402cf97d799582d5c6ea1dfa2a97a4fb4bdd9d7e056873c5e4998b016dfe9b6743237162fec60a2bf4082b86abf82dedb5ed87f07bc4cf9310350bd1c8f947c66ef019d6f25df0eaad7990bf7a773ff7abe5d2cf0831614ac6997dee8074d31f0e4bb3b9e978fb1d7d80df894fcbdec0103275c796cac180245f31dcbc19d3871b7f159550ffaa3df98f467b7be88a214662055701b145dc4873c50ec54c89baed7b9c43ec596f6370fcef0878cf70d25a1bb5f058364a277f1d44f980e01d62a88dc69b9e152059097c4799fcd2d42d8c3469e38d544764dc5ddbe59ad379cd64f1e2d5d904d1410acf012c3f7b0d8e9476614fed30cc82f6884b39b4169fc00a5fd164e2d0c352ed259fe8bb593b600409d41a035ed4542943045cf4404d0d8cf10784ea650f258e5e5425691822c20970c791141a7ff99d1194602c3234b78a067c051633a16473b99dce5d57b6cb332f50f480dbedc1fdbce67722e22315283e84baf443521a15e2bbedb275267aef94544dc8b85aca82d1b0793f97881ae1f9620021c15466a4664b1ca0dce7ee170dd31d65f162d2ff0ed545659405b40f0286993ecd7ef5ea14fefd192dc2ce697faddc106d17f5854e33f6896a78317c8569f95edb4735d681bc133c93a0265a862fe556435e87ae08d06eb61477b04c46666f3b55360b4a2eb4b737e766ca01a555e5bc313382c26d803f8333532119a1c0dbdff34bfbb8239d0188b9d3d154c9bd0eec50067a1c880d71f8bacba034c11f1a81ecb5c8ec68cfcf06dd03621580fde53587fe1d3304858ae2547a0dd52baf1ff91acb48df8f8c695e684f72d83528247b0020cab9e504ba4a0a83cdc10123ef2926ca8028d564279ff498de446f0bc6d5ced9524a9435f0852ca8075230b5a45125a08a9b28905dcf621a4b3bb21bb2735d526250f6cbe2cc657526be019c9799067164c5d63cefb82a90f1ad22d7681357182d252102c4fc49b7189590fa17fae2cb85e30a0fdee20b1d8fe6b0ad2846077f138afd29cdb1e26128899e85964e82c182482502c95cbbdd4b86a53a87c722afaf920b2ca8e890051e5999a9e5328589ecfdf54a9d51ba893afd80bd22b8397dc0a95505b6fd9739a7949a0958c2e422023d1cad75268556c5764df3e16f7262d3bc390700f04f92bb3183ff97a8c04253c56e9be80476bf87d3032602361c01efb2d9e2ee9904408537e7b463d56b5ca04834516222ac8b32b73acd112abe520a9cd11ae3c71c3e67c167237a7cbb9557ab3a40842973c1b0e9adf6d7a48a3469cad3cae141e0c652e8007cb832ac817b887d52bdb4f7b6c3aed6df5352dddcdeab772d52f1cfc8bfb624684da8d8f6eee219865477e8fe7e157ca301521093103db688eb2e4cdb6c1a964ebf38dd11f41a0178fb4614b02a4c13a124050dec3d078f9da8e1349009232be1e3577cdd1bf049aa5e86af26221ee5ee566b06f7f92ac64a1af15d93cee12f2f932232e0470b424bcf40ea06173b31badf117cb3636d0856d103ad624d22caaa3921725ca3f0443a1fd31604336de0d31faf10166eb1cc14517abadb671d7a726ea8c5741654e12b6df466a425280f758d92c13b02e176f6180578c3cc2c1b4fa446adb01ff0a705747cc7b81edb813c5339e6d31aab0ac57a4a96567ddbeb06097775b9ea6bc1bd7dd9e4b988decd1b72c6d7da65cb9901a83a53fa56239986478f35dc6f9ec7e1407f934ab5c45a236ca6b6d410a5dff430265329f23dd9a9814f68f66f3920a72f0e099596d98681aaceba5a2fa6208065182844f11329d2454c548b8cdf0d38b08eac7b770c8413821075274f8d1ddc61ca3c8d51c3d86911863869d51efd04bead13bae5be31dbcf48570328ced315f27b34cd43ca93f277b2f0811b81ed6c093ccc08205f5da0c580711dc881b07b0316fe2dffc7d44024a7c9bad0a8ea179421ab7c1adcb9b3f20eb8d11e0e376f5ccc3bd4d0cd385b40a4711247b23d1f6e45454fa204150956cb6ce77063cca2fb7fc6c93accb33313bff9305ed5131fce52318ee310837eca049b8427314ee9f570bde12006150ba49d2a2ba8b84d9feb738555697c4a7f6b4f6ad5887bd6f0a134a180c44e369601b8e4b29cfde71ed578595bbc0140191d4c15ddf59b96bb4c0d30e0c43a0894a4149371a9c284f77fa4fdd9b315edefcdd7a22243e3dfd480348116c3cc811631662721eaf3b404e92cb5e344177a3fd540413a8482c4aedfe656aaab875caefd51fcec9836601820dd8ff0cce97b6927e5e10bf83a01bc8b28674cad7ae5fe4963b1c279625adf92fd8ec3a4be00d1b7b182bd835eb43b4e86969f57d2dbd193231c0bb2226f254142440460c8e15e9a74dba7cae56e671b9eb385232361639c7fcdefd2a788a5893a6143c34eb96009a06a04b867f371311137c2f099334cf9333d47c307227fca5840abaad9bbaca2fe41aeaf30d3378b017d86725430b728515ed20dc64065949536704d88054d3d40c3b23f3f1db130370f11a88b0754514cd4b2440b462e27005dd323ab13c144698ef1fd6b1778b6fcb21011602a3236cdf9ab946e56a7c525e99bec89a4d69d6ebbe60b71a0e0c397a108630678f68e96257104df23c29d41b03361e7df7d0c370cc7f11027ecc195f3f381ccece3bef48b1f9ab05a0de6015fb8c367c2a035838016d2be391d7984a541d19993752d0716416b81213eac47a655e82d11ba863dece5ff76ac494aee0b52f87acdeb075405a0a5353a368c6fe7536107ac7fc88dde87625102b101ab1c78e75f7169a46d7faaf159d7169269920b3c8eb6d69aa4970876e42a32def6ca2d8587f0a36f274b73b125474693579e44b912b65997cd5dc298b48805cf742366e71e1448fb89617abfb972a483b89357237d19d661c839693aa9035e6c1808f9d89774eac5bee36aea237d60e1fe96bfb8d13a02df1db6149fb48d6e7eafb12010ade18d96dbe04710a3a181d7712ebdfe17c6b1d9f4219e3891383fd9461d035bb422e1f068f8a5aee80e46acbba47732e5ee1feadfe703738a30fd23c8195e03b61b019b54189d676eaedb51849df68f87feb05e38133e357097bd902943324690b27c02c88b3d3decb828bf67512be5e611813bc0acc12ddc77bb67e915ce7e6dc874a2bf81ac9937501783f1f3cdb002726f80193ac8d037fb5da44d664491f123cab8303871a208a95b5832fc9aed91d4b3c1cf1eeeabde1a1b6ba1c61dddd3868ac13adccc5f1c6f29752c5fa22ab7ae0c931493f3937836e3fd19a60dd579178ce881961ec3b8509bbe90d6a3b1ccd2acbebcca8b60310ed1959e36d22b9498e7dc21625256aa6e20d0af6588d7e2af304d6eadbb66b2ba4e9c2714749044e5d2\n  \n    \n      \n      \n        Hey, password is required here.\n      \n    \n  \n\n","slug":"private","date":"2019-05-27T05:48:25.000Z","categories_index":"private","tags_index":"private","author_index":"Stephen"},{"id":"fc9ed1ed6c42c869484f950e1dcd4824","title":"Jetbrains 全家桶免费用","content":"Jetbrains软件激活方法下载激活包启动IDE，如果上来就需要注册，选择：试用（Evaluate for free）进入IDE点击你要注册的IDE菜单：”Configure” 或 “Help” -&gt; “Edit Custom VM Options …”      \n\n在打开的vmoptions编辑窗口末行添加：”-javaagent:&#x2F;absolute&#x2F;path&#x2F;to&#x2F;jetbrains-agent.jar” (填写你存放 jetbrains-agent.jar 文件的绝对路径)     \n  \n重启IDE。点击IDE菜单 “Help” -&gt; “Register…” 或 “Configure” -&gt; “Manage License…”      \n  \n填写激活码       \n  \n激活成功     \n        \n  \n\n激活包下载\n\n\n\n\n\n\n\n\n软件包:  点击下载  (Mac  Win 通用)\nArticle link： https://tqgoblin.site/post/Jetbrains/  Author： Stephen  \n","slug":"Jetbrains","date":"2019-03-02T02:48:00.000Z","categories_index":"软件","tags_index":"软件","author_index":"Stephen"},{"id":"f5234097a5a9cdb48e6197f98eea9fe5","title":"Spring boot 工程访问不到webapp文件下资源","content":"  当我们用IntelliJ IDEA 启动 springBoot新项目访问webapp下的静态页面时出现404，且没有任何错误的情况下\n\n   \n    \n   \n\n解决方案\n\n   \n    \n   \n   \n  \n    \n   \n\n\nArticle link： https://tqgoblin.site/post/spring-boot-bug-webapp/  Author： Stephen  \n","slug":"spring-boot-bug-webapp","date":"2018-09-02T02:48:00.000Z","categories_index":"踩坑之路","tags_index":"JSP","author_index":"Stephen"},{"id":"296290365ed946b345a31171d65dd645","title":"基于freemaker 逆向工程","content":"\n    \n\n\n  public class MysqlUtil &#123;\n    static &#123;\n        try &#123;\n            Class.forName(&quot;com.mysql.jdbc.Driver&quot;);\n        &#125; catch (ClassNotFoundException e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;获取连接\n    public static Connection getConnection(Configuration configuration) throws SQLException &#123;\n        String url &#x3D; &quot;jdbc:mysql:&#x2F;&#x2F;&quot;+configuration.getAddress()+&quot;:&quot;+configuration.getPort();\n        Connection connection &#x3D; null;\n        connection &#x3D; DriverManager.getConnection(url, configuration.getUserName(), configuration.getPassword());\n        connection.setAutoCommit(true);\n        return connection;\n    &#125;\n\n    &#x2F;&#x2F;释放资源\n    public static void release(Connection connection, Statement statement, ResultSet resultSet) throws SQLException &#123;\n        if (connection!&#x3D;null)&#123;\n            connection.close();\n        &#125;\n        if (statement!&#x3D;null)&#123;\n            statement.close();\n        &#125;\n        if (resultSet!&#x3D;null)&#123;\n            resultSet.close();\n        &#125;\n    &#125;\n\n    &#x2F;&#x2F;执行sql   在控制台中显示所有的数据库名称\n    public static void executeSqlForShowDatabases(Connection connection,Configuration configuration) throws SQLException &#123;\n        Statement statement &#x3D; connection.createStatement();\n        ResultSet resultSet &#x3D; statement.executeQuery(&quot;show databases;&quot;);\n        Set&lt;String&gt; databases &#x3D; new HashSet&lt;String&gt;();\n        while (resultSet.next())&#123;\n            String databaseName &#x3D; resultSet.getString(1);\n            databases.add(databaseName);\n            System.out.println(databaseName);\n        &#125;\n        configuration.setDatabases(databases);\n        MysqlUtil.release(null,statement,resultSet);\n    &#125;\n\n    &#x2F;&#x2F;执行sql    显示所有的表名称\n    public static void executeSqlForShowTables(Connection connection,Configuration configuration) throws SQLException &#123;\n        Statement statement &#x3D; connection.createStatement();\n        statement.execute(&quot;use &quot;+configuration.getDatabase());\n        ResultSet resultSet &#x3D; statement.executeQuery(&quot;show tables&quot;);\n        Set&lt;String&gt; tables &#x3D; new HashSet&lt;String&gt;();\n        while (resultSet.next())&#123;\n            String tableName &#x3D; resultSet.getString(1);\n            tables.add(tableName);\n            System.out.println(tableName);\n        &#125;\n        MysqlUtil.release(null,statement,resultSet);\n    &#125;\n\n    &#x2F;&#x2F;执行sql   查看表结构  能拿到表的字段 以及字段的数据类型\n    public static void executeSqlForDescTable(Connection connection,Configuration configuration) throws SQLException &#123;\n        Statement statement &#x3D; connection.createStatement();\n        ResultSet resultSet &#x3D; statement.executeQuery(&quot;desc &quot;+configuration.getTable());\n        Set&lt;ColumnModel&gt; columnModels &#x3D; new HashSet&lt;ColumnModel&gt;();&#x2F;&#x2F;当前这个表中所有的字段及类型\n        while (resultSet.next())&#123;\n            String columnName &#x3D; resultSet.getString(1);\n            String columnType &#x3D; resultSet.getString(2);\n            ColumnModel columnModel &#x3D; new ColumnModel();\n            columnModel.setColumnName(columnName);\n            if (columnType.contains(&quot;varchar&quot;)||columnType.contains(&quot;char&quot;))&#123;\n                columnModel.setType(&quot;String&quot;);\n            &#125;else if (columnType.contains(&quot;int&quot;))&#123;\n                columnModel.setType(&quot;Integer&quot;);\n            &#125;else if (columnType.contains(&quot;datetime&quot;))&#123;\n                columnModel.setType(&quot;Date&quot;);\n            &#125;else if (columnType.contains(&quot;bigint&quot;))&#123;\n                columnModel.setType(&quot;Long&quot;);\n            &#125;\n            columnModels.add(columnModel);\n&#x2F;&#x2F;            System.out.println(columnName+&quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;&quot;+columnType);\n        &#125;\n        TableModel tableModel &#x3D; new TableModel();\n        tableModel.setTableName(configuration.getTable());\n        tableModel.setColumnModels(columnModels);\n        configuration.setTableModel(tableModel);\n        MysqlUtil.release(null,statement,resultSet);\n\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n\n源码:  点击下载 \nArticle link： https://tqgoblin.site/post/codegenerator/  Author： Stephen  \n","slug":"codegenerator","date":"2018-08-12T02:48:00.000Z","categories_index":"软件","tags_index":"软件","author_index":"Stephen"},{"id":"d30ace39e1775eb881fa386d10463fa5","title":"正整数分解质因数","content":"将一个正整数分解质因数。例如：输入90，打印出90&#x3D;2*3*3*5    public class Solution &#123;\n        public static void main(String[] args) &#123;\n            Scanner sc &#x3D; new Scanner(System.in);\n            System.out.println(&quot;请输入要分解的正整数：&quot;);\n            int n &#x3D; sc.nextInt();\n            StringBuilder sb &#x3D; new StringBuilder();\n            sb.append(n + &quot;&#x3D;&quot;);\n            &#x2F;&#x2F;逻辑是：从2-n中找一个最小的且能被n整除的数k\n            &#x2F;&#x2F;如果找到了 就用 n&#x2F;k 的商作为新n  继续循环\n            &#x2F;&#x2F;如果n &#x3D;&#x3D; k 则说明是质数 或者商是质数 就循环结束直接输出\n            for (int i &#x3D; 2; i &lt; n + 1; i++) &#123;\n                while (n % i &#x3D;&#x3D; 0 &amp;&amp; n !&#x3D; i) &#123;\n                    n &#x3D; n &#x2F; i;\n                    sb.append(i + &quot;*&quot;);\n                &#125;\n    \n                if (n &#x3D;&#x3D; i) &#123;     &#x2F;&#x2F;如果上面的都不能整除说明是个质数\n                    sb.append(i);\n                    break;\n                &#125;\n            &#125;\n        System.out.println(sb.toString());\n    &#125;\n&#125;\n\n\nArticle link： https://tqgoblin.site/post/正整数分解质因数/  Author： Stephen  \n","slug":"正整数分解质因数","date":"2018-04-13T05:48:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"Stephen"},{"id":"ef5a4863e88e0b505e528fa60d638cfe","title":"Hannuota","content":"Java 实现 汉诺塔解法汉诺塔：汉诺塔问题是源于印度一个古老传说的益智玩具。大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。并且规定，在小圆盘上不能放大圆盘，在三根柱子之间一次只能移动一个圆盘。\n     \n\npublic class Solution &#123;\n    public static void main(String[] args) &#123;\n        int n &#x3D; 3;\n        char from &#x3D; &#39;A&#39;;\n        char in &#x3D; &#39;B&#39;;\n        char to &#x3D; &#39;c&#39;;\n        func(n, from, in, to);\n    &#125;\n\n    private static void func(int n, char from, char in, char to) &#123;\n        if (n &#x3D;&#x3D; 1) &#123;\n            System.out.println(&quot;将第&quot; + n + &quot;块从&quot; + from + &quot;移到&quot; + to);\n            &#x2F;&#x2F; 无论有多少盘子 都看成2个盘子 ， 最后一个盘子和 上面的所有盘子\n        &#125; else &#123;\n            &#x2F;&#x2F; 将除最后一个之外的所有的盘子移到  temp位置去\n            func(n - 1, from, to, in);\n            &#x2F;&#x2F; 将最后一个盘子移到目标位置\n            System.out.println(&quot;将第&quot; + n + &quot;块从&quot; + from + &quot;移到&quot; + to);\n            &#x2F;&#x2F; 再将n-1个盘子从 temp移到目标位置\n            func(n - 1, in, from, to);\n\n        &#125;\n    &#125;\n&#125;\n\n\n\nArticle link： https://tqgoblin.site/post/Hannuota/  Author： Stephen  \n","slug":"Hannuota","date":"2018-04-10T02:09:00.000Z","categories_index":"算法","tags_index":"算法","author_index":"Stephen"}]