{"total":49,"pageSize":13,"pageCount":4,"data":[{"title":"如何更好地使用Kafka","uid":"af845c075b322bafbf0dd249cd968eb7","slug":"csdn/如何更好地使用Kafka","date":"2022-12-01T09:31:05.000Z","updated":"2025-02-17T04:32:37.063Z","comments":true,"path":"api/articles/csdn/如何更好地使用Kafka.json","keywords":"Stephen web3","cover":"../img/1c8d68e9dec35793796ea26cf1f6a419.jpg","text":"引言 要确保Kafka在使用过程中的稳定性，需要从kafka在业务中的使用周期进行依次保障。主要可以分为：事先预防（通过规范的使用、开发，预防问题产生）、运行时...","permalink":"/post/csdn/如何更好地使用Kafka","photos":[],"count_time":{"symbolsCount":"15k","symbolsTime":"14 mins."},"categories":[{"name":"mq","slug":"mq","count":5,"path":"api/categories/mq.json"}],"tags":[{"name":"kafka java 大数据","slug":"kafka-java-大数据","count":1,"path":"api/tags/kafka-java-大数据.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"RocketMQ介绍","uid":"23a83ea7b13859971f6150dc36d3dd3b","slug":"csdn/RocketMQ介绍","date":"2022-11-10T09:36:17.000Z","updated":"2025-02-17T04:31:59.814Z","comments":true,"path":"api/articles/csdn/RocketMQ介绍.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/UTOOLS1577681541276.jpg","text":"RocketMQ 整体架构设计 整体的架构设计主要分为四大部分，分别是：Producer、Consumer、Broker、NameServer。 为了更贴合实际...","permalink":"/post/csdn/RocketMQ介绍","photos":[],"count_time":{"symbolsCount":"9.3k","symbolsTime":"8 mins."},"categories":[{"name":"mq","slug":"mq","count":5,"path":"api/categories/mq.json"}],"tags":[{"name":"面试 面试 java-rocketmq","slug":"面试-面试-java-rocketmq","count":1,"path":"api/tags/面试-面试-java-rocketmq.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"RocketMQ与kafka的区别","uid":"a66c39428303def8c1769f2fae79ffad","slug":"csdn/RocketMQ与kafka的区别","date":"2022-11-10T09:13:06.000Z","updated":"2025-02-17T04:32:55.070Z","comments":true,"path":"api/articles/csdn/RocketMQ与kafka的区别.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/blog/bimg/68db4265-fa19-408a-81bc-d8ebed6537db.jpg","text":"一、前言 淘宝内部的交易系统使用了淘宝自主研发的Notify消息中间件，使用MySQL作为消息存储媒介，支持水平扩容。为了进一步降低成本，阿里中间件团队认为No...","permalink":"/post/csdn/RocketMQ与kafka的区别","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"mq","slug":"mq","count":5,"path":"api/categories/mq.json"}],"tags":[{"name":"面试 kafka 面试","slug":"面试-kafka-面试","count":1,"path":"api/tags/面试-kafka-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"kafka的rebalance机制","uid":"4a7935236206ce0c80a1379bd98b2262","slug":"csdn/kafka的rebalance机制","date":"2022-11-10T08:01:25.000Z","updated":"2025-02-17T04:35:04.466Z","comments":true,"path":"api/articles/csdn/kafka的rebalance机制.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/blog/bimg/toolbagShader.png","text":"一、Reblance是什么 Reblance就像他的名称一样，意思是再平衡，平衡什么？平衡消费者和分区之间的对应关系。本质上来讲，Reblance是一种协议，规...","permalink":"/post/csdn/kafka的rebalance机制","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"kafka kafka 面试","slug":"kafka-kafka-面试","count":1,"path":"api/tags/kafka-kafka-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"HashMap底层原理","uid":"5c0f27a0ed8d73f08892501931e4fc3a","slug":"csdn/HashMap底层原理","date":"2022-10-18T08:56:52.000Z","updated":"2025-02-17T04:33:24.500Z","comments":true,"path":"api/articles/csdn/HashMap底层原理.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/blog/bimg/68db4265-fa19-408a-81bc-d8ebed6537db.jpg","text":" 一、HashMap特点：数组＋链表存储数据 线理不安全 默认数组大小16，2倍扩容，扩容因子0.75 HashMap 基于键 HashCode 值唯一标识一条...","permalink":"/post/csdn/HashMap底层原理","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"面试 java","slug":"面试-java","count":1,"path":"api/tags/面试-java.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Spring加载流程","uid":"92e817b0edbefb52af49230332579af2","slug":"csdn/Spring加载流程","date":"2022-10-18T08:43:29.000Z","updated":"2025-02-17T04:22:34.847Z","comments":true,"path":"api/articles/csdn/Spring加载流程.json","keywords":"Stephen web3","cover":[],"text":"一、spring加载流程 tomcat在启动ServletContext容器的时候会发布ServletContextEvent事件，Spring就通过实现Ser...","permalink":"/post/csdn/Spring加载流程","photos":[],"count_time":{"symbolsCount":"3.3k","symbolsTime":"3 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"spring spring java 面试","slug":"spring-spring-java-面试","count":1,"path":"api/tags/spring-spring-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"SpringMVC介绍","uid":"5702e63d59ce606e9e7b7128f2ea5bdd","slug":"csdn/springMVC介绍","date":"2022-10-18T06:59:27.000Z","updated":"2025-02-17T04:30:49.781Z","comments":true,"path":"api/articles/csdn/springMVC介绍.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/UTOOLS1577681541276.jpg","text":"一、springmvc初始化 我们使用springMVC的时候，它的主要入口时dispatcherServlet类，它最终实现了Servlet接口。Servle...","permalink":"/post/csdn/springMVC介绍","photos":[],"count_time":{"symbolsCount":"3.9k","symbolsTime":"4 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"面试 java spring","slug":"面试-java-spring","count":1,"path":"api/tags/面试-java-spring.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"java中的锁","uid":"1c003f281cf294408d7d24cc6188aa8e","slug":"csdn/java中的锁","date":"2022-10-14T15:40:19.000Z","updated":"2025-02-17T04:33:33.329Z","comments":true,"path":"api/articles/csdn/java中的锁.json","keywords":"Stephen web3","cover":"https://stblogs.oss-cn-chengdu.aliyuncs.com/blog/bimg/68db4265-fa19-408a-81bc-d8ebed6537db.jpg","text":"1. 乐观锁 VS 悲观锁乐观锁与悲观锁是一种广义上的概念，体现了看待线程同步的不同角度。在Java和数据库中都有此概念对应的实际应用。 先说概念。对于同一个数...","permalink":"/post/csdn/java中的锁","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"锁 java 面试","slug":"锁-java-面试","count":1,"path":"api/tags/锁-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"简单介绍Kafka","uid":"65befa2e81f1cf5d027b510d356d0eda","slug":"csdn/简单介绍Kafka","date":"2022-10-13T15:38:26.000Z","updated":"2025-02-17T04:22:34.820Z","comments":true,"path":"api/articles/csdn/简单介绍Kafka.json","keywords":"Stephen web3","cover":[],"text":"Kafka 概念Kafka 是一种高吞吐量、分布式、基于发布/订阅的消息系统，最初由 LinkedIn 公司开发，使用Scala 语言编写，目前是 Apache...","permalink":"/post/csdn/简单介绍Kafka","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"kafka kafka","slug":"kafka-kafka","count":1,"path":"api/tags/kafka-kafka.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"java并发关键字","uid":"f00905d171c4323a2676ba94b49d2b6c","slug":"csdn/java并发关键字","date":"2022-10-11T03:27:15.000Z","updated":"2025-02-17T04:22:34.733Z","comments":true,"path":"api/articles/csdn/java并发关键字.json","keywords":"Stephen web3","cover":[],"text":"一、CountDownLatch CountDownLatch类位于java.util.concurrent包下，是一个同步工具类 ，允许一个或多个线程一直等待...","permalink":"/post/csdn/java并发关键字","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"Java 面试 java","slug":"Java-面试-java","count":1,"path":"api/tags/Java-面试-java.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"什么是AQS","uid":"7d9db4929e21c0d91333dbdc28b79909","slug":"csdn/什么是AQS","date":"2022-10-10T15:35:06.000Z","updated":"2025-02-17T04:22:34.715Z","comments":true,"path":"api/articles/csdn/什么是AQS.json","keywords":"Stephen web3","cover":[],"text":" AQS ( Abstract Queued Synchronizer ）是一个抽象的队列同步器，通过维护一个共享资源状态（ Volatile Int Stat...","permalink":"/post/csdn/什么是AQS","photos":[],"count_time":{"symbolsCount":"1.8k","symbolsTime":"2 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"面试 java 面试","slug":"面试-java-面试","count":1,"path":"api/tags/面试-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"什么是 CAS","uid":"2a388c0d390bb47b986af930ed26f977","slug":"csdn/什么是 CAS","date":"2022-10-10T14:58:41.000Z","updated":"2025-02-17T04:22:34.834Z","comments":true,"path":"api/articles/csdn/什么是 CAS.json","keywords":"Stephen web3","cover":[],"text":"一、CAS 的概念：比较并交换 CAS (Compare And Swap）指比较并交换。CAS算法 CAS(V,E,N)包含3个参数，V表示要更新的变量，E表...","permalink":"/post/csdn/什么是 CAS","photos":[],"count_time":{"symbolsCount":"1.3k","symbolsTime":"1 mins."},"categories":[{"name":"面试","slug":"面试","count":5,"path":"api/categories/面试.json"}],"tags":[{"name":"Java java 面试","slug":"Java-java-面试","count":1,"path":"api/tags/Java-java-面试.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}},{"title":"Java阻塞队列","uid":"32c93abe435d8f794f6c98ee11259476","slug":"csdn/Java阻塞队列","date":"2022-10-10T09:52:53.000Z","updated":"2025-02-17T04:22:34.793Z","comments":true,"path":"api/articles/csdn/Java阻塞队列.json","keywords":"Stephen web3","cover":[],"text":"概述 队列是种只允许在表的前端进行删除操作，而在表的后端进行插入操作的线性表。阻塞队列和一般队列的不同之处在于阻塞队列是“阻塞”的，这里的阻塞指的是操作队 列的...","permalink":"/post/csdn/Java阻塞队列","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Java","slug":"Java","count":15,"path":"api/categories/Java.json"}],"tags":[{"name":"Java","slug":"Java","count":2,"path":"api/tags/Java.json"}],"author":{"name":"Stephen","slug":"blog-author","avatar":"../img/logo.png","link":"/","description":"Love and Share","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}}}]}